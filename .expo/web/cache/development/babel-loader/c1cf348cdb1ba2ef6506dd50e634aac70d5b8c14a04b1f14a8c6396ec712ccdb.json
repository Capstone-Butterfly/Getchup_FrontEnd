{"ast":null,"code":"function $c5a24bc478652b5f$export$1005530eda016c13(node, collection) {\n  if (typeof collection.getChildren === 'function') return collection.getChildren(node.key);\n  return node.childNodes;\n}\nfunction $c5a24bc478652b5f$export$fbdeaa6a76694f71(iterable) {\n  return $c5a24bc478652b5f$export$5f3398f8733f90e2(iterable, 0);\n}\nfunction $c5a24bc478652b5f$export$5f3398f8733f90e2(iterable, index) {\n  if (index < 0) return undefined;\n  let i = 0;\n  for (let item of iterable) {\n    if (i === index) return item;\n    i++;\n  }\n}\nfunction $c5a24bc478652b5f$export$7475b2c64539e4cf(iterable) {\n  let lastItem = undefined;\n  for (let value of iterable) lastItem = value;\n  return lastItem;\n}\nfunction $c5a24bc478652b5f$export$8c434b3a7a4dad6(collection, a, b) {\n  if (a.parentKey === b.parentKey) return a.index - b.index;\n  let aAncestors = [...$c5a24bc478652b5f$var$getAncestors(collection, a), a];\n  let bAncestors = [...$c5a24bc478652b5f$var$getAncestors(collection, b), b];\n  let firstNonMatchingAncestor = aAncestors.slice(0, bAncestors.length).findIndex((a, i) => a !== bAncestors[i]);\n  if (firstNonMatchingAncestor !== -1) {\n    a = aAncestors[firstNonMatchingAncestor];\n    b = bAncestors[firstNonMatchingAncestor];\n    return a.index - b.index;\n  }\n  if (aAncestors.findIndex(node => node === b) >= 0) return 1;else if (bAncestors.findIndex(node => node === a) >= 0) return -1;\n  return -1;\n}\nfunction $c5a24bc478652b5f$var$getAncestors(collection, node) {\n  let parents = [];\n  while ((node === null || node === void 0 ? void 0 : node.parentKey) != null) {\n    node = collection.getItem(node.parentKey);\n    parents.unshift(node);\n  }\n  return parents;\n}\nexport { $c5a24bc478652b5f$export$1005530eda016c13 as getChildNodes, $c5a24bc478652b5f$export$fbdeaa6a76694f71 as getFirstItem, $c5a24bc478652b5f$export$5f3398f8733f90e2 as getNthItem, $c5a24bc478652b5f$export$7475b2c64539e4cf as getLastItem, $c5a24bc478652b5f$export$8c434b3a7a4dad6 as compareNodeOrder };","map":{"version":3,"names":["$c5a24bc478652b5f$export$1005530eda016c13","node","collection","getChildren","key","childNodes","$c5a24bc478652b5f$export$fbdeaa6a76694f71","iterable","$c5a24bc478652b5f$export$5f3398f8733f90e2","index","undefined","i","item","$c5a24bc478652b5f$export$7475b2c64539e4cf","lastItem","value","$c5a24bc478652b5f$export$8c434b3a7a4dad6","a","b","parentKey","aAncestors","$c5a24bc478652b5f$var$getAncestors","bAncestors","firstNonMatchingAncestor","slice","length","findIndex","parents","getItem","unshift"],"sources":["/Users/farhang/Desktop/June 17 /Front/Getchup_FrontEnd/node_modules/@react-stately/collections/dist/packages/@react-stately/collections/src/getChildNodes.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport type {Collection, Node} from '@react-types/shared';\n\nexport function getChildNodes<T>(node: Node<T>, collection: Collection<Node<T>>): Iterable<Node<T>> {\n  // New API: call collection.getChildren with the node key.\n  if (typeof collection.getChildren === 'function') {\n    return collection.getChildren(node.key);\n  }\n\n  // Old API: access childNodes directly.\n  return node.childNodes;\n}\n\nexport function getFirstItem<T>(iterable: Iterable<T>): T | undefined {\n  return getNthItem(iterable, 0);\n}\n\nexport function getNthItem<T>(iterable: Iterable<T>, index: number): T | undefined {\n  if (index < 0) {\n    return undefined;\n  }\n\n  let i = 0;\n  for (let item of iterable) {\n    if (i === index) {\n      return item;\n    }\n\n    i++;\n  }\n}\n\nexport function getLastItem<T>(iterable: Iterable<T>): T | undefined {\n  let lastItem = undefined;\n  for (let value of iterable) {\n    lastItem = value;\n  }\n\n  return lastItem;\n}\n\nexport function compareNodeOrder<T>(collection: Collection<Node<T>>, a: Node<T>, b: Node<T>) {\n  // If the two nodes have the same parent, compare their indices.\n  if (a.parentKey === b.parentKey) {\n    return a.index - b.index;\n  }\n\n  // Otherwise, collect all of the ancestors from each node, and find the first one that doesn't match starting from the root.\n  // Include the base nodes in case we are comparing nodes of different levels so that we can compare the higher node to the lower level node's\n  // ancestor of the same level\n  let aAncestors = [...getAncestors(collection, a), a];\n  let bAncestors = [...getAncestors(collection, b), b];\n  let firstNonMatchingAncestor = aAncestors.slice(0, bAncestors.length).findIndex((a, i) => a !== bAncestors[i]);\n  if (firstNonMatchingAncestor !== -1) {\n    // Compare the indices of two children within the common ancestor.\n    a = aAncestors[firstNonMatchingAncestor];\n    b = bAncestors[firstNonMatchingAncestor];\n    return a.index - b.index;\n  }\n\n  // If there isn't a non matching ancestor, we might be in a case where one of the nodes is the ancestor of the other.\n  if (aAncestors.findIndex(node => node === b) >= 0) {\n    return 1;\n  } else if (bAncestors.findIndex(node => node === a) >= 0) {\n    return -1;\n  }\n\n  // ðŸ¤·\n  return -1;\n}\n\nfunction getAncestors<T>(collection: Collection<Node<T>>, node: Node<T>): Node<T>[] {\n  let parents = [];\n\n  while (node?.parentKey != null) {\n    node = collection.getItem(node.parentKey);\n    parents.unshift(node);\n  }\n\n  return parents;\n}\n"],"mappings":"AAcO,SAASA,0CAAiBC,IAAa,EAAEC,UAA+B;EAE7E,IAAI,OAAOA,UAAA,CAAWC,WAAW,KAAK,YACpC,OAAOD,UAAA,CAAWC,WAAW,CAACF,IAAA,CAAKG,GAAG;EAIxC,OAAOH,IAAA,CAAKI,UAAU;AACxB;AAEO,SAASC,0CAAgBC,QAAqB;EACnD,OAAOC,yCAAA,CAAWD,QAAA,EAAU;AAC9B;AAEO,SAASC,0CAAcD,QAAqB,EAAEE,KAAa;EAChE,IAAIA,KAAA,GAAQ,GACV,OAAOC,SAAA;EAGT,IAAIC,CAAA,GAAI;EACR,KAAK,IAAIC,IAAA,IAAQL,QAAA,EAAU;IACzB,IAAII,CAAA,KAAMF,KAAA,EACR,OAAOG,IAAA;IAGTD,CAAA;EACF;AACF;AAEO,SAASE,0CAAeN,QAAqB;EAClD,IAAIO,QAAA,GAAWJ,SAAA;EACf,KAAK,IAAIK,KAAA,IAASR,QAAA,EAChBO,QAAA,GAAWC,KAAA;EAGb,OAAOD,QAAA;AACT;AAEO,SAASE,yCAAoBd,UAA+B,EAAEe,CAAU,EAAEC,CAAU;EAEzF,IAAID,CAAA,CAAEE,SAAS,KAAKD,CAAA,CAAEC,SAAS,EAC7B,OAAOF,CAAA,CAAER,KAAK,GAAGS,CAAA,CAAET,KAAK;EAM1B,IAAIW,UAAA,GAAa,C,GAAIC,kCAAA,CAAanB,UAAA,EAAYe,CAAA,GAAIA,CAAA,CAAE;EACpD,IAAIK,UAAA,GAAa,C,GAAID,kCAAA,CAAanB,UAAA,EAAYgB,CAAA,GAAIA,CAAA,CAAE;EACpD,IAAIK,wBAAA,GAA2BH,UAAA,CAAWI,KAAK,CAAC,GAAGF,UAAA,CAAWG,MAAM,EAAEC,SAAS,CAAC,CAACT,CAAA,EAAGN,CAAA,KAAMM,CAAA,KAAMK,UAAU,CAACX,CAAA,CAAE;EAC7G,IAAIY,wBAAA,KAA6B,IAAI;IAEnCN,CAAA,GAAIG,UAAU,CAACG,wBAAA,CAAyB;IACxCL,CAAA,GAAII,UAAU,CAACC,wBAAA,CAAyB;IACxC,OAAON,CAAA,CAAER,KAAK,GAAGS,CAAA,CAAET,KAAK;EAC1B;EAGA,IAAIW,UAAA,CAAWM,SAAS,CAACzB,IAAA,IAAQA,IAAA,KAASiB,CAAA,KAAM,GAC9C,OAAO,OACF,IAAII,UAAA,CAAWI,SAAS,CAACzB,IAAA,IAAQA,IAAA,KAASgB,CAAA,KAAM,GACrD,OAAO;EAIT,OAAO;AACT;AAEA,SAASI,mCAAgBnB,UAA+B,EAAED,IAAa;EACrE,IAAI0B,OAAA,GAAU,EAAE;EAEhB,OAAO,CAAA1B,IAAA,aAAAA,IAAA,uBAAAA,IAAA,CAAMkB,SAAS,KAAI,MAAM;IAC9BlB,IAAA,GAAOC,UAAA,CAAW0B,OAAO,CAAC3B,IAAA,CAAKkB,SAAS;IACxCQ,OAAA,CAAQE,OAAO,CAAC5B,IAAA;EAClB;EAEA,OAAO0B,OAAA;AACT","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}