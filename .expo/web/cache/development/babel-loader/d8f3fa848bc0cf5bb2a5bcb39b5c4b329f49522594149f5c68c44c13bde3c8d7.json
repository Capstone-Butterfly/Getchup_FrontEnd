{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport { calculatePosition } from './calculatePosition';\nimport { useCallback, useRef, useState } from 'react';\nimport { useCloseOnScroll } from './useCloseOnScroll';\nimport { isRTL, useLayoutEffect } from '@react-native-aria/utils';\nlet visualViewport = true && window.visualViewport;\nexport function useOverlayPosition(props) {\n  var _targetRef$current, _targetRef$current2;\n  const direction = isRTL() ? 'rtl' : undefined;\n  let {\n    targetRef,\n    overlayRef,\n    scrollRef = overlayRef,\n    placement = 'bottom',\n    containerPadding = 12,\n    shouldFlip = true,\n    boundaryElement = typeof document !== 'undefined' ? document.body : null,\n    offset = 0,\n    crossOffset = 0,\n    shouldUpdatePosition = true,\n    isOpen = true,\n    shouldOverlapWithTrigger = false,\n    onClose\n  } = props;\n  let [position, setPosition] = useState({\n    position: {},\n    arrowOffsetLeft: undefined,\n    arrowOffsetTop: undefined,\n    maxHeight: undefined,\n    placement: undefined\n  });\n  let deps = [shouldUpdatePosition, placement, overlayRef.current, (_targetRef$current = targetRef.current) === null || _targetRef$current === void 0 ? void 0 : _targetRef$current.offsetLeft, (_targetRef$current2 = targetRef.current) === null || _targetRef$current2 === void 0 ? void 0 : _targetRef$current2.offsetTop, scrollRef.current, containerPadding, shouldFlip, boundaryElement, offset, crossOffset, isOpen, direction, shouldOverlapWithTrigger];\n  let updatePosition = useCallback(() => {\n    if (shouldUpdatePosition === false || !isOpen || !overlayRef.current || !targetRef.current || !scrollRef.current || !boundaryElement) {\n      return;\n    }\n    setPosition(calculatePosition({\n      placement: translateRTL(placement, direction),\n      overlayNode: overlayRef.current,\n      targetNode: targetRef.current,\n      scrollNode: scrollRef.current,\n      padding: containerPadding,\n      shouldFlip,\n      boundaryElement,\n      offset,\n      crossOffset,\n      shouldOverlapWithTrigger\n    }));\n  }, deps);\n  useLayoutEffect(updatePosition, deps);\n  useResize(updatePosition);\n  let isResizing = useRef(false);\n  useLayoutEffect(() => {\n    let timeout;\n    let onResize = () => {\n      isResizing.current = true;\n      clearTimeout(timeout);\n      timeout = setTimeout(() => {\n        isResizing.current = false;\n      }, 500);\n      updatePosition();\n    };\n    visualViewport === null || visualViewport === void 0 || visualViewport.addEventListener('resize', onResize);\n    return () => {\n      visualViewport === null || visualViewport === void 0 || visualViewport.removeEventListener('resize', onResize);\n    };\n  }, [updatePosition]);\n  let close = useCallback(() => {\n    if (!isResizing.current) {\n      onClose();\n    }\n  }, [onClose, isResizing]);\n  useCloseOnScroll({\n    triggerRef: targetRef,\n    isOpen,\n    onClose: onClose ? close : undefined\n  });\n  return {\n    rendered: true,\n    overlayProps: {\n      style: _objectSpread(_objectSpread({\n        position: 'absolute',\n        zIndex: 100000\n      }, position.position), {}, {\n        maxHeight: position.maxHeight\n      })\n    },\n    placement: position.placement,\n    arrowProps: {\n      style: {\n        left: position.arrowOffsetLeft,\n        top: position.arrowOffsetTop\n      }\n    },\n    updatePosition\n  };\n}\nfunction useResize(onResize) {\n  useLayoutEffect(() => {\n    window.addEventListener('resize', onResize, false);\n    return () => {\n      window.removeEventListener('resize', onResize, false);\n    };\n  }, [onResize]);\n}\nfunction translateRTL(position, direction) {\n  if (direction === 'rtl') {\n    return position.replace('start', 'right').replace('end', 'left');\n  }\n  return position.replace('start', 'left').replace('end', 'right');\n}","map":{"version":3,"names":["calculatePosition","useCallback","useRef","useState","useCloseOnScroll","isRTL","useLayoutEffect","visualViewport","window","useOverlayPosition","props","_targetRef$current","_targetRef$current2","direction","undefined","targetRef","overlayRef","scrollRef","placement","containerPadding","shouldFlip","boundaryElement","document","body","offset","crossOffset","shouldUpdatePosition","isOpen","shouldOverlapWithTrigger","onClose","position","setPosition","arrowOffsetLeft","arrowOffsetTop","maxHeight","deps","current","offsetLeft","offsetTop","updatePosition","translateRTL","overlayNode","targetNode","scrollNode","padding","useResize","isResizing","timeout","onResize","clearTimeout","setTimeout","addEventListener","removeEventListener","close","triggerRef","rendered","overlayProps","style","_objectSpread","zIndex","arrowProps","left","top","replace"],"sources":["/Users/farhang/Desktop/June 17 /Front/Getchup_FrontEnd/node_modules/@react-native-aria/overlays/src/web/overlays/src/useOverlayPosition.ts"],"sourcesContent":["//@ts-nocheck\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport { calculatePosition, PositionResult } from './calculatePosition';\nimport {\n  HTMLAttributes,\n  RefObject,\n  useCallback,\n  useRef,\n  useState,\n} from 'react';\nimport { Placement, PlacementAxis, PositionProps } from '@react-types/overlays';\nimport { useCloseOnScroll } from './useCloseOnScroll';\nimport { isRTL, useLayoutEffect } from '@react-native-aria/utils';\n\ninterface AriaPositionProps extends PositionProps {\n  /**\n   * Element that that serves as the positioning boundary.\n   * @default document.body\n   */\n  boundaryElement?: HTMLElement;\n  /**\n   * The ref for the element which the overlay positions itself with respect to.\n   */\n  targetRef: RefObject<HTMLElement>;\n  /**\n   * The ref for the overlay element.\n   */\n  overlayRef: RefObject<HTMLElement>;\n  /**\n   * A ref for the scrollable region within the overlay.\n   * @default overlayRef\n   */\n  scrollRef?: RefObject<HTMLElement>;\n  /**\n   * Whether the overlay should update its position automatically.\n   * @default true\n   */\n  shouldUpdatePosition?: boolean;\n  /** Handler that is called when the overlay should close. */\n  onClose?: () => void;\n  /** Determines whether the overlay should overlap with the trigger */\n  shouldOverlapWithTrigger?: boolean;\n}\n\ninterface PositionAria {\n  /** Props for the overlay container element. */\n  overlayProps: HTMLAttributes<Element>;\n  /** Props for the overlay tip arrow if any. */\n  arrowProps: HTMLAttributes<Element>;\n  /** Placement of the overlay with respect to the overlay trigger. */\n  placement: PlacementAxis;\n  /** Updates the position of the overlay. */\n  updatePosition(): void;\n}\n\n// @ts-ignore\nlet visualViewport = typeof window !== 'undefined' && window.visualViewport;\n\n/**\n * Handles positioning overlays like popovers and menus relative to a trigger\n * element, and updating the position when the window resizes.\n */\nexport function useOverlayPosition(props: AriaPositionProps): PositionAria {\n  const direction = isRTL() ? 'rtl' : undefined;\n  let {\n    targetRef,\n    overlayRef,\n    scrollRef = overlayRef,\n    placement = 'bottom' as Placement,\n    containerPadding = 12,\n    shouldFlip = true,\n    boundaryElement = typeof document !== 'undefined' ? document.body : null,\n    offset = 0,\n    crossOffset = 0,\n    shouldUpdatePosition = true,\n    isOpen = true,\n    shouldOverlapWithTrigger = false,\n    onClose,\n  } = props;\n  let [position, setPosition] = useState<PositionResult>({\n    position: {},\n    arrowOffsetLeft: undefined,\n    arrowOffsetTop: undefined,\n    maxHeight: undefined,\n    placement: undefined,\n  });\n\n  let deps = [\n    shouldUpdatePosition,\n    placement,\n    overlayRef.current,\n    targetRef.current?.offsetLeft,\n    targetRef.current?.offsetTop,\n    scrollRef.current,\n    containerPadding,\n    shouldFlip,\n    boundaryElement,\n    offset,\n    crossOffset,\n    isOpen,\n    direction,\n    shouldOverlapWithTrigger,\n  ];\n\n  let updatePosition = useCallback(() => {\n    if (\n      shouldUpdatePosition === false ||\n      !isOpen ||\n      !overlayRef.current ||\n      !targetRef.current ||\n      !scrollRef.current ||\n      !boundaryElement\n    ) {\n      return;\n    }\n\n    setPosition(\n      calculatePosition({\n        placement: translateRTL(placement, direction),\n        overlayNode: overlayRef.current,\n        targetNode: targetRef.current,\n        scrollNode: scrollRef.current,\n        padding: containerPadding,\n        shouldFlip,\n        boundaryElement,\n        offset,\n        crossOffset,\n        shouldOverlapWithTrigger,\n      })\n    );\n  }, deps);\n\n  // Update position when anything changes\n  useLayoutEffect(updatePosition, deps);\n\n  // Update position on window resize\n  useResize(updatePosition);\n\n  // Reposition the overlay and do not close on scroll while the visual viewport is resizing.\n  // This will ensure that overlays adjust their positioning when the iOS virtual keyboard appears.\n  let isResizing = useRef(false);\n  useLayoutEffect(() => {\n    let timeout: NodeJS.Timeout;\n    let onResize = () => {\n      isResizing.current = true;\n      clearTimeout(timeout);\n\n      timeout = setTimeout(() => {\n        isResizing.current = false;\n      }, 500);\n\n      updatePosition();\n    };\n\n    visualViewport?.addEventListener('resize', onResize);\n\n    return () => {\n      visualViewport?.removeEventListener('resize', onResize);\n    };\n  }, [updatePosition]);\n\n  let close = useCallback(() => {\n    if (!isResizing.current) {\n      onClose();\n    }\n  }, [onClose, isResizing]);\n\n  // When scrolling a parent scrollable region of the trigger (other than the body),\n  // we hide the popover. Otherwise, its position would be incorrect.\n  useCloseOnScroll({\n    triggerRef: targetRef,\n    isOpen,\n    onClose: onClose ? close : undefined,\n  });\n\n  // useLayoutEffect(() => {\n  //   const mutationObserver = new MutationObserver((mutations) => {\n  //     updatePosition();\n  //     mutations.forEach((mutation) => {\n  //       // if (mutation.attributeName === 'style') {\n  //       //   const transform = mutation.target.style.transform;\n  //       //   if (transform) {\n  //       //     const match = transform.match(/scale\\((.+)\\)/);\n  //       //     if (match) {\n  //       //       const scale = parseFloat(match[1]);\n  //       //       console.log(`Scale: ${scale}`);\n  //       //       // updatePosition();\n  //       //     }\n  //       //   }\n  //       // }\n  //     });\n  //   });\n\n  //   mutationObserver.observe(overlayRef?.current, { attributes: true });\n\n  //   return () => mutationObserver.disconnect();\n  // }, [overlayRef, updatePosition]);\n\n  return {\n    rendered: true,\n    overlayProps: {\n      style: {\n        position: 'absolute',\n        zIndex: 100000, // should match the z-index in ModalTrigger\n        ...position.position,\n        maxHeight: position.maxHeight,\n      },\n    },\n    placement: position.placement,\n    arrowProps: {\n      style: {\n        left: position.arrowOffsetLeft,\n        top: position.arrowOffsetTop,\n      },\n    },\n    updatePosition,\n  };\n}\n\nfunction useResize(onResize) {\n  useLayoutEffect(() => {\n    window.addEventListener('resize', onResize, false);\n    return () => {\n      window.removeEventListener('resize', onResize, false);\n    };\n  }, [onResize]);\n}\n\nfunction translateRTL(position, direction) {\n  if (direction === 'rtl') {\n    return position.replace('start', 'right').replace('end', 'left');\n  }\n  return position.replace('start', 'left').replace('end', 'right');\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}