{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport { getItemCount } from '@react-stately/collections';\nimport { isFocusVisible, useKeyboard } from '@react-aria/interactions';\nimport { useHover, usePress } from '@react-native-aria/interactions';\nimport { mapDomPropsToRN } from '@react-native-aria/utils';\nimport { mergeProps, useSlotId } from '@react-aria/utils';\nimport { useSelectableItem } from '@react-aria/selection';\nexport function useMenuItem(props, state, ref) {\n  let {\n    isSelected,\n    isDisabled,\n    key,\n    onClose,\n    closeOnSelect = true,\n    isVirtualized,\n    onAction\n  } = props;\n  let role = 'menuitem';\n  if (state.selectionManager.selectionMode === 'single') {\n    role = 'menuitemradio';\n  } else if (state.selectionManager.selectionMode === 'multiple') {\n    role = 'menuitemcheckbox';\n  }\n  let labelId = useSlotId();\n  let descriptionId = useSlotId();\n  let keyboardId = useSlotId();\n  let ariaProps = {\n    'aria-disabled': isDisabled,\n    role,\n    'aria-label': props['aria-label'],\n    'aria-labelledby': labelId,\n    'aria-describedby': [descriptionId, keyboardId].filter(Boolean).join(' ') || undefined\n  };\n  if (state.selectionManager.selectionMode !== 'none') {\n    ariaProps['aria-checked'] = isSelected;\n  }\n  if (isVirtualized) {\n    ariaProps['aria-posinset'] = state.collection.getItem(key).index;\n    ariaProps['aria-setsize'] = getItemCount(state.collection);\n  }\n  let onPressStart = e => {\n    if (e.pointerType === 'keyboard' && onAction) {\n      onAction(key);\n    }\n  };\n  let onPress = () => {\n    if (closeOnSelect && onClose) {\n      onClose();\n    }\n  };\n  let onPressUp = e => {\n    if (e.pointerType !== 'keyboard') {\n      if (onAction) {\n        onAction(key);\n      }\n    }\n  };\n  let {\n    itemProps\n  } = useSelectableItem({\n    selectionManager: state.selectionManager,\n    key,\n    ref,\n    shouldSelectOnPressUp: true\n  });\n  let {\n    pressProps\n  } = usePress(mergeProps({\n    onPressStart,\n    onPressUp,\n    onPress,\n    isDisabled\n  }, mapDomPropsToRN(itemProps)));\n  let {\n    hoverProps\n  } = useHover({\n    isDisabled,\n    onHoverStart() {\n      if (!isFocusVisible()) {\n        state.selectionManager.setFocused(true);\n        state.selectionManager.setFocusedKey(key);\n      }\n    }\n  }, ref);\n  const {\n    keyboardProps\n  } = useKeyboard({\n    onKeyDown: e => {\n      if (e.repeat) {\n        e.continuePropagation();\n        return;\n      }\n      switch (e.key) {\n        case ' ':\n          if (!isDisabled && closeOnSelect && onClose) {\n            onClose();\n          }\n          break;\n        case 'Enter':\n          if (!isDisabled && closeOnSelect && onClose) {\n            onClose();\n          }\n          break;\n        default:\n          e.continuePropagation();\n          break;\n      }\n    }\n  });\n  return {\n    menuItemProps: _objectSpread(_objectSpread({}, mapDomPropsToRN(ariaProps)), mergeProps(pressProps, hoverProps, keyboardProps)),\n    labelProps: {\n      id: labelId\n    },\n    descriptionProps: {\n      id: descriptionId\n    },\n    keyboardShortcutProps: {\n      id: keyboardId\n    }\n  };\n}","map":{"version":3,"names":["getItemCount","isFocusVisible","useKeyboard","useHover","usePress","mapDomPropsToRN","mergeProps","useSlotId","useSelectableItem","useMenuItem","props","state","ref","isSelected","isDisabled","key","onClose","closeOnSelect","isVirtualized","onAction","role","selectionManager","selectionMode","labelId","descriptionId","keyboardId","ariaProps","filter","Boolean","join","undefined","collection","getItem","index","onPressStart","e","pointerType","onPress","onPressUp","itemProps","shouldSelectOnPressUp","pressProps","hoverProps","onHoverStart","setFocused","setFocusedKey","keyboardProps","onKeyDown","repeat","continuePropagation","menuItemProps","_objectSpread","labelProps","id","descriptionProps","keyboardShortcutProps"],"sources":["/Users/farhang/Desktop/June 17 /Front/Getchup_FrontEnd/node_modules/@react-native-aria/menu/src/useMenuItem.web.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport { getItemCount } from '@react-stately/collections';\nimport { Key, RefObject } from 'react';\nimport { isFocusVisible, useKeyboard } from '@react-aria/interactions';\nimport { useHover, usePress } from '@react-native-aria/interactions';\nimport { mapDomPropsToRN } from '@react-native-aria/utils';\nimport { mergeProps, useSlotId } from '@react-aria/utils';\nimport { PressEvent } from '@react-types/shared';\nimport { TreeState } from '@react-stately/tree';\nimport { useSelectableItem } from '@react-aria/selection';\nimport { ViewProps } from 'react-native';\ninterface MenuItemAria {\n  /** Props for the menu item element. */\n  menuItemProps: ViewProps;\n\n  /** Props for the main text element inside the menu item. */\n  labelProps: ViewProps;\n\n  /** Props for the description text element inside the menu item, if any. */\n  descriptionProps: ViewProps;\n\n  /** Props for the keyboard shortcut text element inside the item, if any. */\n  keyboardShortcutProps: ViewProps;\n}\n\ninterface AriaMenuItemProps {\n  /** Whether the menu item is disabled. */\n  'isDisabled'?: boolean;\n\n  /** Whether the menu item is selected. */\n  'isSelected'?: boolean;\n\n  /** A screen reader only label for the menu item. */\n  'aria-label'?: string;\n\n  /** The unique key for the menu item. */\n  'key'?: any;\n\n  /** Handler that is called when the menu should close after selecting an item. */\n  'onClose'?: () => void;\n\n  /**\n   * Whether the menu should close when the menu item is selected.\n   * @default true\n   */\n  'closeOnSelect'?: boolean;\n\n  /** Whether the menu item is contained in a virtual scrolling menu. */\n  'isVirtualized'?: boolean;\n\n  /** Handler that is called when the user activates the item. */\n  'onAction'?: (key: Key) => void;\n}\n\n/**\n * Provides the behavior and accessibility implementation for an item in a menu.\n * See `useMenu` for more details about menus.\n * @param props - Props for the item.\n * @param state - State for the menu, as returned by `useTreeState`.\n */\nexport function useMenuItem<T>(\n  props: AriaMenuItemProps,\n  state: TreeState<T>,\n  ref: RefObject<HTMLElement>\n): MenuItemAria {\n  let {\n    isSelected,\n    isDisabled,\n    key,\n    onClose,\n    closeOnSelect = true,\n    isVirtualized,\n    onAction,\n  } = props;\n\n  let role = 'menuitem';\n  if (state.selectionManager.selectionMode === 'single') {\n    role = 'menuitemradio';\n  } else if (state.selectionManager.selectionMode === 'multiple') {\n    role = 'menuitemcheckbox';\n  }\n\n  let labelId = useSlotId();\n  let descriptionId = useSlotId();\n  let keyboardId = useSlotId();\n\n  let ariaProps: any = {\n    'aria-disabled': isDisabled,\n    role,\n    'aria-label': props['aria-label'],\n    'aria-labelledby': labelId,\n    'aria-describedby':\n      [descriptionId, keyboardId].filter(Boolean).join(' ') || undefined,\n  };\n  if (state.selectionManager.selectionMode !== 'none') {\n    ariaProps['aria-checked'] = isSelected;\n  }\n\n  if (isVirtualized) {\n    ariaProps['aria-posinset'] = state.collection.getItem(key).index;\n    ariaProps['aria-setsize'] = getItemCount(state.collection);\n  }\n\n  let onPressStart = (e: PressEvent) => {\n    if (e.pointerType === 'keyboard' && onAction) {\n      onAction(key);\n    }\n  };\n\n  let onPress = () => {\n    if (closeOnSelect && onClose) {\n      onClose();\n    }\n  };\n  let onPressUp = (e: PressEvent) => {\n    if (e.pointerType !== 'keyboard') {\n      if (onAction) {\n        onAction(key);\n      }\n    }\n  };\n\n  let { itemProps } = useSelectableItem({\n    selectionManager: state.selectionManager,\n    key,\n    ref,\n    shouldSelectOnPressUp: true,\n  });\n\n  let { pressProps } = usePress(\n    mergeProps(\n      { onPressStart, onPressUp, onPress, isDisabled },\n      mapDomPropsToRN(itemProps)\n    )\n  );\n\n  let { hoverProps } = useHover(\n    {\n      isDisabled,\n      onHoverStart() {\n        if (!isFocusVisible()) {\n          state.selectionManager.setFocused(true);\n          state.selectionManager.setFocusedKey(key);\n        }\n      },\n    },\n    ref\n  );\n\n  const { keyboardProps } = useKeyboard({\n    onKeyDown: (e) => {\n      // Ignore repeating events, which may have started on the menu trigger before moving\n      // focus to the menu item. We want to wait for a second complete key press sequence.\n      if (e.repeat) {\n        e.continuePropagation();\n        return;\n      }\n      switch (e.key) {\n        case ' ':\n          if (!isDisabled && closeOnSelect && onClose) {\n            onClose();\n          }\n          break;\n        case 'Enter':\n          // The Enter key should always close on select, except if overridden.\n          if (!isDisabled && closeOnSelect && onClose) {\n            onClose();\n          }\n          break;\n        default:\n          e.continuePropagation();\n          break;\n      }\n    },\n  });\n\n  return {\n    menuItemProps: {\n      ...mapDomPropsToRN(ariaProps),\n      ...mergeProps(pressProps, hoverProps, keyboardProps),\n    },\n    labelProps: {\n      id: labelId,\n    },\n    descriptionProps: {\n      id: descriptionId,\n    },\n    keyboardShortcutProps: {\n      id: keyboardId,\n    },\n  };\n}\n"],"mappings":";;;AAYA,SAASA,YAAY,QAAQ,4BAA4B;AAEzD,SAASC,cAAc,EAAEC,WAAW,QAAQ,0BAA0B;AACtE,SAASC,QAAQ,EAAEC,QAAQ,QAAQ,iCAAiC;AACpE,SAASC,eAAe,QAAQ,0BAA0B;AAC1D,SAASC,UAAU,EAAEC,SAAS,QAAQ,mBAAmB;AAGzD,SAASC,iBAAiB,QAAQ,uBAAuB;AAmDzD,OAAO,SAASC,WAAWA,CACzBC,KAAwB,EACxBC,KAAmB,EACnBC,GAA2B,EACb;EACd,IAAI;IACFC,UAAU;IACVC,UAAU;IACVC,GAAG;IACHC,OAAO;IACPC,aAAa,GAAG,IAAI;IACpBC,aAAa;IACbC;EACF,CAAC,GAAGT,KAAK;EAET,IAAIU,IAAI,GAAG,UAAU;EACrB,IAAIT,KAAK,CAACU,gBAAgB,CAACC,aAAa,KAAK,QAAQ,EAAE;IACrDF,IAAI,GAAG,eAAe;EACxB,CAAC,MAAM,IAAIT,KAAK,CAACU,gBAAgB,CAACC,aAAa,KAAK,UAAU,EAAE;IAC9DF,IAAI,GAAG,kBAAkB;EAC3B;EAEA,IAAIG,OAAO,GAAGhB,SAAS,CAAC,CAAC;EACzB,IAAIiB,aAAa,GAAGjB,SAAS,CAAC,CAAC;EAC/B,IAAIkB,UAAU,GAAGlB,SAAS,CAAC,CAAC;EAE5B,IAAImB,SAAc,GAAG;IACnB,eAAe,EAAEZ,UAAU;IAC3BM,IAAI;IACJ,YAAY,EAAEV,KAAK,CAAC,YAAY,CAAC;IACjC,iBAAiB,EAAEa,OAAO;IAC1B,kBAAkB,EAChB,CAACC,aAAa,EAAEC,UAAU,CAAC,CAACE,MAAM,CAACC,OAAO,CAAC,CAACC,IAAI,CAAC,GAAG,CAAC,IAAIC;EAC7D,CAAC;EACD,IAAInB,KAAK,CAACU,gBAAgB,CAACC,aAAa,KAAK,MAAM,EAAE;IACnDI,SAAS,CAAC,cAAc,CAAC,GAAGb,UAAU;EACxC;EAEA,IAAIK,aAAa,EAAE;IACjBQ,SAAS,CAAC,eAAe,CAAC,GAAGf,KAAK,CAACoB,UAAU,CAACC,OAAO,CAACjB,GAAG,CAAC,CAACkB,KAAK;IAChEP,SAAS,CAAC,cAAc,CAAC,GAAG1B,YAAY,CAACW,KAAK,CAACoB,UAAU,CAAC;EAC5D;EAEA,IAAIG,YAAY,GAAIC,CAAa,IAAK;IACpC,IAAIA,CAAC,CAACC,WAAW,KAAK,UAAU,IAAIjB,QAAQ,EAAE;MAC5CA,QAAQ,CAACJ,GAAG,CAAC;IACf;EACF,CAAC;EAED,IAAIsB,OAAO,GAAGA,CAAA,KAAM;IAClB,IAAIpB,aAAa,IAAID,OAAO,EAAE;MAC5BA,OAAO,CAAC,CAAC;IACX;EACF,CAAC;EACD,IAAIsB,SAAS,GAAIH,CAAa,IAAK;IACjC,IAAIA,CAAC,CAACC,WAAW,KAAK,UAAU,EAAE;MAChC,IAAIjB,QAAQ,EAAE;QACZA,QAAQ,CAACJ,GAAG,CAAC;MACf;IACF;EACF,CAAC;EAED,IAAI;IAAEwB;EAAU,CAAC,GAAG/B,iBAAiB,CAAC;IACpCa,gBAAgB,EAAEV,KAAK,CAACU,gBAAgB;IACxCN,GAAG;IACHH,GAAG;IACH4B,qBAAqB,EAAE;EACzB,CAAC,CAAC;EAEF,IAAI;IAAEC;EAAW,CAAC,GAAGrC,QAAQ,CAC3BE,UAAU,CACR;IAAE4B,YAAY;IAAEI,SAAS;IAAED,OAAO;IAAEvB;EAAW,CAAC,EAChDT,eAAe,CAACkC,SAAS,CAC3B,CACF,CAAC;EAED,IAAI;IAAEG;EAAW,CAAC,GAAGvC,QAAQ,CAC3B;IACEW,UAAU;IACV6B,YAAYA,CAAA,EAAG;MACb,IAAI,CAAC1C,cAAc,CAAC,CAAC,EAAE;QACrBU,KAAK,CAACU,gBAAgB,CAACuB,UAAU,CAAC,IAAI,CAAC;QACvCjC,KAAK,CAACU,gBAAgB,CAACwB,aAAa,CAAC9B,GAAG,CAAC;MAC3C;IACF;EACF,CAAC,EACDH,GACF,CAAC;EAED,MAAM;IAAEkC;EAAc,CAAC,GAAG5C,WAAW,CAAC;IACpC6C,SAAS,EAAGZ,CAAC,IAAK;MAGhB,IAAIA,CAAC,CAACa,MAAM,EAAE;QACZb,CAAC,CAACc,mBAAmB,CAAC,CAAC;QACvB;MACF;MACA,QAAQd,CAAC,CAACpB,GAAG;QACX,KAAK,GAAG;UACN,IAAI,CAACD,UAAU,IAAIG,aAAa,IAAID,OAAO,EAAE;YAC3CA,OAAO,CAAC,CAAC;UACX;UACA;QACF,KAAK,OAAO;UAEV,IAAI,CAACF,UAAU,IAAIG,aAAa,IAAID,OAAO,EAAE;YAC3CA,OAAO,CAAC,CAAC;UACX;UACA;QACF;UACEmB,CAAC,CAACc,mBAAmB,CAAC,CAAC;UACvB;MACJ;IACF;EACF,CAAC,CAAC;EAEF,OAAO;IACLC,aAAa,EAAAC,aAAA,CAAAA,aAAA,KACR9C,eAAe,CAACqB,SAAS,CAAC,GAC1BpB,UAAU,CAACmC,UAAU,EAAEC,UAAU,EAAEI,aAAa,EACpD;IACDM,UAAU,EAAE;MACVC,EAAE,EAAE9B;IACN,CAAC;IACD+B,gBAAgB,EAAE;MAChBD,EAAE,EAAE7B;IACN,CAAC;IACD+B,qBAAqB,EAAE;MACrBF,EAAE,EAAE5B;IACN;EACF,CAAC;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}