{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport { getFormatOptions as $35a22f14a1f04b11$export$7e319ea407e63bc0, getPlaceholderTime as $35a22f14a1f04b11$export$c5221a78ef73c5e9, getRangeValidationResult as $35a22f14a1f04b11$export$80ff8fc0ae339c13, useDefaultProps as $35a22f14a1f04b11$export$2440da353cedad43 } from \"./utils.mjs\";\nimport { toCalendarDate as $hac8C$toCalendarDate, toCalendarDateTime as $hac8C$toCalendarDateTime, DateFormatter as $hac8C$DateFormatter } from \"@internationalized/date\";\nimport { useFormValidationState as $hac8C$useFormValidationState } from \"@react-stately/form\";\nimport { useOverlayTriggerState as $hac8C$useOverlayTriggerState } from \"@react-stately/overlays\";\nimport { useControlledState as $hac8C$useControlledState } from \"@react-stately/utils\";\nimport { useState as $hac8C$useState, useMemo as $hac8C$useMemo } from \"react\";\nfunction $93c38a5e28be6249$export$e50a61c1de9f574(props) {\n  var _value_start, _value_end;\n  let overlayState = (0, $hac8C$useOverlayTriggerState)(props);\n  let [controlledValue, setControlledValue] = (0, $hac8C$useControlledState)(props.value, props.defaultValue || null, props.onChange);\n  let [placeholderValue, setPlaceholderValue] = (0, $hac8C$useState)(() => controlledValue || {\n    start: null,\n    end: null\n  });\n  if (controlledValue == null && placeholderValue.start && placeholderValue.end) {\n    placeholderValue = {\n      start: null,\n      end: null\n    };\n    setPlaceholderValue(placeholderValue);\n  }\n  let value = controlledValue || placeholderValue;\n  let setValue = value => {\n    setPlaceholderValue(value || {\n      start: null,\n      end: null\n    });\n    if ((value === null || value === void 0 ? void 0 : value.start) && value.end) setControlledValue(value);else setControlledValue(null);\n  };\n  let v = (value === null || value === void 0 ? void 0 : value.start) || (value === null || value === void 0 ? void 0 : value.end) || props.placeholderValue;\n  let [granularity, defaultTimeZone] = (0, $35a22f14a1f04b11$export$2440da353cedad43)(v, props.granularity);\n  let hasTime = granularity === 'hour' || granularity === 'minute' || granularity === 'second';\n  var _props_shouldCloseOnSelect;\n  let shouldCloseOnSelect = (_props_shouldCloseOnSelect = props.shouldCloseOnSelect) !== null && _props_shouldCloseOnSelect !== void 0 ? _props_shouldCloseOnSelect : true;\n  let [dateRange, setSelectedDateRange] = (0, $hac8C$useState)(null);\n  let [timeRange, setSelectedTimeRange] = (0, $hac8C$useState)(null);\n  if (value && value.start && value.end) {\n    dateRange = value;\n    if ('hour' in value.start) timeRange = value;\n  }\n  let commitValue = (dateRange, timeRange) => {\n    setValue({\n      start: 'timeZone' in timeRange.start ? timeRange.start.set((0, $hac8C$toCalendarDate)(dateRange.start)) : (0, $hac8C$toCalendarDateTime)(dateRange.start, timeRange.start),\n      end: 'timeZone' in timeRange.end ? timeRange.end.set((0, $hac8C$toCalendarDate)(dateRange.end)) : (0, $hac8C$toCalendarDateTime)(dateRange.end, timeRange.end)\n    });\n    setSelectedDateRange(null);\n    setSelectedTimeRange(null);\n    validation.commitValidation();\n  };\n  let setDateRange = range => {\n    let shouldClose = typeof shouldCloseOnSelect === 'function' ? shouldCloseOnSelect() : shouldCloseOnSelect;\n    if (hasTime) {\n      if (shouldClose || range.start && range.end && (timeRange === null || timeRange === void 0 ? void 0 : timeRange.start) && (timeRange === null || timeRange === void 0 ? void 0 : timeRange.end)) commitValue(range, {\n        start: (timeRange === null || timeRange === void 0 ? void 0 : timeRange.start) || (0, $35a22f14a1f04b11$export$c5221a78ef73c5e9)(props.placeholderValue),\n        end: (timeRange === null || timeRange === void 0 ? void 0 : timeRange.end) || (0, $35a22f14a1f04b11$export$c5221a78ef73c5e9)(props.placeholderValue)\n      });else setSelectedDateRange(range);\n    } else if (range.start && range.end) {\n      setValue(range);\n      validation.commitValidation();\n    } else setSelectedDateRange(range);\n    if (shouldClose) overlayState.setOpen(false);\n  };\n  let setTimeRange = range => {\n    if ((dateRange === null || dateRange === void 0 ? void 0 : dateRange.start) && (dateRange === null || dateRange === void 0 ? void 0 : dateRange.end) && range.start && range.end) commitValue(dateRange, range);else setSelectedTimeRange(range);\n  };\n  let showEra = (value === null || value === void 0 ? void 0 : (_value_start = value.start) === null || _value_start === void 0 ? void 0 : _value_start.calendar.identifier) === 'gregory' && value.start.era === 'BC' || (value === null || value === void 0 ? void 0 : (_value_end = value.end) === null || _value_end === void 0 ? void 0 : _value_end.calendar.identifier) === 'gregory' && value.end.era === 'BC';\n  let formatOpts = (0, $hac8C$useMemo)(() => ({\n    granularity: granularity,\n    timeZone: defaultTimeZone,\n    hideTimeZone: props.hideTimeZone,\n    hourCycle: props.hourCycle,\n    shouldForceLeadingZeros: props.shouldForceLeadingZeros,\n    showEra: showEra\n  }), [granularity, props.hourCycle, props.shouldForceLeadingZeros, defaultTimeZone, props.hideTimeZone, showEra]);\n  let {\n    minValue: minValue,\n    maxValue: maxValue,\n    isDateUnavailable: isDateUnavailable\n  } = props;\n  let builtinValidation = (0, $hac8C$useMemo)(() => (0, $35a22f14a1f04b11$export$80ff8fc0ae339c13)(value, minValue, maxValue, isDateUnavailable, formatOpts), [value, minValue, maxValue, isDateUnavailable, formatOpts]);\n  let validation = (0, $hac8C$useFormValidationState)(_objectSpread(_objectSpread({}, props), {}, {\n    value: controlledValue,\n    name: (0, $hac8C$useMemo)(() => [props.startName, props.endName], [props.startName, props.endName]),\n    builtinValidation: builtinValidation\n  }));\n  let isValueInvalid = validation.displayValidation.isInvalid;\n  let validationState = props.validationState || (isValueInvalid ? 'invalid' : null);\n  return _objectSpread(_objectSpread(_objectSpread({}, validation), {}, {\n    value: value,\n    setValue: setValue,\n    dateRange: dateRange,\n    timeRange: timeRange,\n    granularity: granularity,\n    hasTime: hasTime,\n    setDate(part, date) {\n      setDateRange(_objectSpread(_objectSpread({}, dateRange), {}, {\n        [part]: date\n      }));\n    },\n    setTime(part, time) {\n      setTimeRange(_objectSpread(_objectSpread({}, timeRange), {}, {\n        [part]: time\n      }));\n    },\n    setDateTime(part, dateTime) {\n      setValue(_objectSpread(_objectSpread({}, value), {}, {\n        [part]: dateTime\n      }));\n    },\n    setDateRange: setDateRange,\n    setTimeRange: setTimeRange\n  }, overlayState), {}, {\n    setOpen(isOpen) {\n      if (!isOpen && !((value === null || value === void 0 ? void 0 : value.start) && (value === null || value === void 0 ? void 0 : value.end)) && (dateRange === null || dateRange === void 0 ? void 0 : dateRange.start) && (dateRange === null || dateRange === void 0 ? void 0 : dateRange.end) && hasTime) commitValue(dateRange, {\n        start: (timeRange === null || timeRange === void 0 ? void 0 : timeRange.start) || (0, $35a22f14a1f04b11$export$c5221a78ef73c5e9)(props.placeholderValue),\n        end: (timeRange === null || timeRange === void 0 ? void 0 : timeRange.end) || (0, $35a22f14a1f04b11$export$c5221a78ef73c5e9)(props.placeholderValue)\n      });\n      overlayState.setOpen(isOpen);\n    },\n    validationState: validationState,\n    isInvalid: isValueInvalid,\n    formatValue(locale, fieldOptions) {\n      if (!value || !value.start || !value.end) return null;\n      let startTimeZone = 'timeZone' in value.start ? value.start.timeZone : undefined;\n      let startGranularity = props.granularity || (value.start && 'minute' in value.start ? 'minute' : 'day');\n      let endTimeZone = 'timeZone' in value.end ? value.end.timeZone : undefined;\n      let endGranularity = props.granularity || (value.end && 'minute' in value.end ? 'minute' : 'day');\n      let startOptions = (0, $35a22f14a1f04b11$export$7e319ea407e63bc0)(fieldOptions, {\n        granularity: startGranularity,\n        timeZone: startTimeZone,\n        hideTimeZone: props.hideTimeZone,\n        hourCycle: props.hourCycle,\n        showEra: value.start.calendar.identifier === 'gregory' && value.start.era === 'BC' || value.end.calendar.identifier === 'gregory' && value.end.era === 'BC'\n      });\n      let startDate = value.start.toDate(startTimeZone || 'UTC');\n      let endDate = value.end.toDate(endTimeZone || 'UTC');\n      let startFormatter = new (0, $hac8C$DateFormatter)(locale, startOptions);\n      let endFormatter;\n      if (startTimeZone === endTimeZone && startGranularity === endGranularity && value.start.compare(value.end) !== 0) {\n        try {\n          let parts = startFormatter.formatRangeToParts(startDate, endDate);\n          let separatorIndex = -1;\n          for (let i = 0; i < parts.length; i++) {\n            let part = parts[i];\n            if (part.source === 'shared' && part.type === 'literal') separatorIndex = i;else if (part.source === 'endRange') break;\n          }\n          let start = '';\n          let end = '';\n          for (let i = 0; i < parts.length; i++) {\n            if (i < separatorIndex) start += parts[i].value;else if (i > separatorIndex) end += parts[i].value;\n          }\n          return {\n            start: start,\n            end: end\n          };\n        } catch (e) {}\n        endFormatter = startFormatter;\n      } else {\n        let endOptions = (0, $35a22f14a1f04b11$export$7e319ea407e63bc0)(fieldOptions, {\n          granularity: endGranularity,\n          timeZone: endTimeZone,\n          hideTimeZone: props.hideTimeZone,\n          hourCycle: props.hourCycle\n        });\n        endFormatter = new (0, $hac8C$DateFormatter)(locale, endOptions);\n      }\n      return {\n        start: startFormatter.format(startDate),\n        end: endFormatter.format(endDate)\n      };\n    }\n  });\n}\nexport { $93c38a5e28be6249$export$e50a61c1de9f574 as useDateRangePickerState };","map":{"version":3,"names":["$93c38a5e28be6249$export$e50a61c1de9f574","props","_value_start","_value_end","overlayState","$hac8C$useOverlayTriggerState","controlledValue","setControlledValue","$hac8C$useControlledState","value","defaultValue","onChange","placeholderValue","setPlaceholderValue","$hac8C$useState","start","end","setValue","v","granularity","defaultTimeZone","$35a22f14a1f04b11$export$2440da353cedad43","hasTime","_props_shouldCloseOnSelect","shouldCloseOnSelect","dateRange","setSelectedDateRange","timeRange","setSelectedTimeRange","commitValue","set","$hac8C$toCalendarDate","$hac8C$toCalendarDateTime","validation","commitValidation","setDateRange","range","shouldClose","$35a22f14a1f04b11$export$c5221a78ef73c5e9","setOpen","setTimeRange","showEra","calendar","identifier","era","formatOpts","$hac8C$useMemo","timeZone","hideTimeZone","hourCycle","shouldForceLeadingZeros","minValue","maxValue","isDateUnavailable","builtinValidation","$35a22f14a1f04b11$export$80ff8fc0ae339c13","$hac8C$useFormValidationState","_objectSpread","name","startName","endName","isValueInvalid","displayValidation","isInvalid","validationState","setDate","part","date","setTime","time","setDateTime","dateTime","isOpen","formatValue","locale","fieldOptions","startTimeZone","undefined","startGranularity","endTimeZone","endGranularity","startOptions","$35a22f14a1f04b11$export$7e319ea407e63bc0","startDate","toDate","endDate","startFormatter","$hac8C$DateFormatter","endFormatter","compare","parts","formatRangeToParts","separatorIndex","i","length","source","type","e","endOptions","format"],"sources":["/Users/farhang/Desktop/June 17 /Front/Getchup_FrontEnd/node_modules/@react-stately/datepicker/dist/packages/@react-stately/datepicker/src/useDateRangePickerState.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DateFormatter, toCalendarDate, toCalendarDateTime} from '@internationalized/date';\nimport {DateRange, DateRangePickerProps, DateValue, Granularity, TimeValue} from '@react-types/datepicker';\nimport {FieldOptions, getFormatOptions, getPlaceholderTime, getRangeValidationResult, useDefaultProps} from './utils';\nimport {FormValidationState, useFormValidationState} from '@react-stately/form';\nimport {OverlayTriggerState, useOverlayTriggerState} from '@react-stately/overlays';\nimport {RangeValue, ValidationState} from '@react-types/shared';\nimport {useControlledState} from '@react-stately/utils';\nimport {useMemo, useState} from 'react';\n\nexport interface DateRangePickerStateOptions<T extends DateValue = DateValue> extends DateRangePickerProps<T> {\n  /**\n   * Determines whether the date picker popover should close automatically when a date is selected.\n   * @default true\n   */\n  shouldCloseOnSelect?: boolean | (() => boolean)\n}\n\ntype TimeRange = RangeValue<TimeValue>;\nexport interface DateRangePickerState extends OverlayTriggerState, FormValidationState {\n  /** The currently selected date range. */\n  value: DateRange | null,\n  /** Sets the selected date range. */\n  setValue(value: DateRange | null): void,\n  /**\n   * The date portion of the selected range. This may be set prior to `value` if the user has\n   * selected a date range but has not yet selected a time range.\n   */\n  dateRange: DateRange | null,\n  /** Sets the date portion of the selected range. */\n  setDateRange(value: DateRange): void,\n  /**\n   * The time portion of the selected range. This may be set prior to `value` if the user has\n   * selected a time range but has not yet selected a date range.\n   */\n  timeRange: TimeRange | null,\n  /** Sets the time portion of the selected range. */\n  setTimeRange(value: TimeRange): void,\n  /** Sets the date portion of either the start or end of the selected range. */\n  setDate(part: 'start' | 'end', value: DateValue): void,\n  /** Sets the time portion of either the start or end of the selected range. */\n  setTime(part: 'start' | 'end', value: TimeValue): void,\n  /** Sets the date and time of either the start or end of the selected range. */\n  setDateTime(part: 'start' | 'end', value: DateValue): void,\n  /** The granularity for the field, based on the `granularity` prop and current value. */\n  granularity: Granularity,\n  /** Whether the date range picker supports selecting times, according to the `granularity` prop and current value. */\n  hasTime: boolean,\n  /** Whether the calendar popover is currently open. */\n  isOpen: boolean,\n  /** Sets whether the calendar popover is open. */\n  setOpen(isOpen: boolean): void,\n  /**\n   * The current validation state of the date range picker, based on the `validationState`, `minValue`, and `maxValue` props.\n   * @deprecated Use `isInvalid` instead.\n   */\n  validationState: ValidationState,\n  /** Whether the date range picker is invalid, based on the `isInvalid`, `minValue`, and `maxValue` props. */\n  isInvalid: boolean,\n  /** Formats the selected range using the given options. */\n  formatValue(locale: string, fieldOptions: FieldOptions): {start: string, end: string}\n}\n\n/**\n * Provides state management for a date range picker component.\n * A date range picker combines two DateFields and a RangeCalendar popover to allow\n * users to enter or select a date and time range.\n */\nexport function useDateRangePickerState<T extends DateValue = DateValue>(props: DateRangePickerStateOptions<T>): DateRangePickerState {\n  let overlayState = useOverlayTriggerState(props);\n  let [controlledValue, setControlledValue] = useControlledState<DateRange>(props.value, props.defaultValue || null, props.onChange);\n  let [placeholderValue, setPlaceholderValue] = useState(() => controlledValue || {start: null, end: null});\n\n  // Reset the placeholder if the value prop is set to null.\n  if (controlledValue == null && placeholderValue.start && placeholderValue.end) {\n    placeholderValue = {start: null, end: null};\n    setPlaceholderValue(placeholderValue);\n  }\n\n  let value = controlledValue || placeholderValue;\n\n  let setValue = (value: DateRange) => {\n    setPlaceholderValue(value || {start: null, end: null});\n    if (value?.start && value.end) {\n      setControlledValue(value);\n    } else {\n      setControlledValue(null);\n    }\n  };\n\n  let v = (value?.start || value?.end || props.placeholderValue);\n  let [granularity, defaultTimeZone] = useDefaultProps(v, props.granularity);\n  let hasTime = granularity === 'hour' || granularity === 'minute' || granularity === 'second';\n  let shouldCloseOnSelect = props.shouldCloseOnSelect ?? true;\n\n  let [dateRange, setSelectedDateRange] = useState<DateRange>(null);\n  let [timeRange, setSelectedTimeRange] = useState<TimeRange>(null);\n\n  if (value && value.start && value.end) {\n    dateRange = value;\n    if ('hour' in value.start) {\n      timeRange = value as TimeRange;\n    }\n  }\n\n  let commitValue = (dateRange: DateRange, timeRange: TimeRange) => {\n    setValue({\n      start: 'timeZone' in timeRange.start ? timeRange.start.set(toCalendarDate(dateRange.start)) : toCalendarDateTime(dateRange.start, timeRange.start),\n      end: 'timeZone' in timeRange.end ? timeRange.end.set(toCalendarDate(dateRange.end)) : toCalendarDateTime(dateRange.end, timeRange.end)\n    });\n    setSelectedDateRange(null);\n    setSelectedTimeRange(null);\n    validation.commitValidation();\n  };\n\n  // Intercept setValue to make sure the Time section is not changed by date selection in Calendar\n  let setDateRange = (range: DateRange) => {\n    let shouldClose = typeof shouldCloseOnSelect === 'function' ? shouldCloseOnSelect() : shouldCloseOnSelect;\n    if (hasTime) {\n      if (shouldClose || (range.start && range.end && timeRange?.start && timeRange?.end)) {\n        commitValue(range, {\n          start: timeRange?.start || getPlaceholderTime(props.placeholderValue),\n          end: timeRange?.end || getPlaceholderTime(props.placeholderValue)\n        });\n      } else {\n        setSelectedDateRange(range);\n      }\n    } else if (range.start && range.end) {\n      setValue(range);\n      validation.commitValidation();\n    } else {\n      setSelectedDateRange(range);\n    }\n\n    if (shouldClose) {\n      overlayState.setOpen(false);\n    }\n  };\n\n  let setTimeRange = (range: TimeRange) => {\n    if (dateRange?.start && dateRange?.end && range.start && range.end) {\n      commitValue(dateRange, range);\n    } else {\n      setSelectedTimeRange(range);\n    }\n  };\n\n  let showEra = (value?.start?.calendar.identifier === 'gregory' && value.start.era === 'BC') || (value?.end?.calendar.identifier === 'gregory' && value.end.era === 'BC');\n  let formatOpts = useMemo(() => ({\n    granularity,\n    timeZone: defaultTimeZone,\n    hideTimeZone: props.hideTimeZone,\n    hourCycle: props.hourCycle,\n    shouldForceLeadingZeros: props.shouldForceLeadingZeros,\n    showEra\n  }), [granularity, props.hourCycle, props.shouldForceLeadingZeros, defaultTimeZone, props.hideTimeZone, showEra]);\n\n  let {minValue, maxValue, isDateUnavailable} = props;\n  let builtinValidation = useMemo(() => getRangeValidationResult(\n    value,\n    minValue,\n    maxValue,\n    isDateUnavailable,\n    formatOpts\n  ), [value, minValue, maxValue, isDateUnavailable, formatOpts]);\n\n  let validation = useFormValidationState({\n    ...props,\n    value: controlledValue,\n    name: useMemo(() => [props.startName, props.endName], [props.startName, props.endName]),\n    builtinValidation\n  });\n\n  let isValueInvalid = validation.displayValidation.isInvalid;\n  let validationState: ValidationState = props.validationState || (isValueInvalid ? 'invalid' : null);\n\n  return {\n    ...validation,\n    value,\n    setValue,\n    dateRange,\n    timeRange,\n    granularity,\n    hasTime,\n    setDate(part, date) {\n      setDateRange({...dateRange, [part]: date});\n    },\n    setTime(part, time) {\n      setTimeRange({...timeRange, [part]: time});\n    },\n    setDateTime(part, dateTime) {\n      setValue({...value, [part]: dateTime});\n    },\n    setDateRange,\n    setTimeRange,\n    ...overlayState,\n    setOpen(isOpen) {\n      // Commit the selected date range when the calendar is closed. Use a placeholder time if one wasn't set.\n      // If only the time range was set and not the date range, don't commit. The state will be preserved until\n      // the user opens the popover again.\n      if (!isOpen && !(value?.start && value?.end) && dateRange?.start && dateRange?.end && hasTime) {\n        commitValue(dateRange, {\n          start: timeRange?.start || getPlaceholderTime(props.placeholderValue),\n          end: timeRange?.end || getPlaceholderTime(props.placeholderValue)\n        });\n      }\n\n      overlayState.setOpen(isOpen);\n    },\n    validationState,\n    isInvalid: isValueInvalid,\n    formatValue(locale, fieldOptions) {\n      if (!value || !value.start || !value.end) {\n        return null;\n      }\n\n      let startTimeZone = 'timeZone' in value.start ? value.start.timeZone : undefined;\n      let startGranularity = props.granularity || (value.start && 'minute' in value.start ? 'minute' : 'day');\n      let endTimeZone = 'timeZone' in value.end ? value.end.timeZone : undefined;\n      let endGranularity = props.granularity || (value.end && 'minute' in value.end ? 'minute' : 'day');\n\n      let startOptions = getFormatOptions(fieldOptions, {\n        granularity: startGranularity,\n        timeZone: startTimeZone,\n        hideTimeZone: props.hideTimeZone,\n        hourCycle: props.hourCycle,\n        showEra: (value.start.calendar.identifier === 'gregory' && value.start.era === 'BC') ||\n          (value.end.calendar.identifier === 'gregory' && value.end.era === 'BC')\n      });\n\n      let startDate = value.start.toDate(startTimeZone || 'UTC');\n      let endDate = value.end.toDate(endTimeZone || 'UTC');\n\n      let startFormatter = new DateFormatter(locale, startOptions);\n      let endFormatter: Intl.DateTimeFormat;\n      if (startTimeZone === endTimeZone && startGranularity === endGranularity && value.start.compare(value.end) !== 0) {\n        // Use formatRange, as it results in shorter output when some of the fields\n        // are shared between the start and end dates (e.g. the same month).\n        // Formatting will fail if the end date is before the start date. Fall back below when that happens.\n        try {\n          let parts = startFormatter.formatRangeToParts(startDate, endDate);\n\n          // Find the separator between the start and end date. This is determined\n          // by finding the last shared literal before the end range.\n          let separatorIndex = -1;\n          for (let i = 0; i < parts.length; i++) {\n            let part = parts[i];\n            if (part.source === 'shared' && part.type === 'literal') {\n              separatorIndex = i;\n            } else if (part.source === 'endRange') {\n              break;\n            }\n          }\n\n          // Now we can combine the parts into start and end strings.\n          let start = '';\n          let end = '';\n          for (let i = 0; i < parts.length; i++) {\n            if (i < separatorIndex) {\n              start += parts[i].value;\n            } else if (i > separatorIndex) {\n              end += parts[i].value;\n            }\n          }\n\n          return {start, end};\n        } catch (e) {\n          // ignore\n        }\n\n        endFormatter = startFormatter;\n      } else {\n        let endOptions = getFormatOptions(fieldOptions, {\n          granularity: endGranularity,\n          timeZone: endTimeZone,\n          hideTimeZone: props.hideTimeZone,\n          hourCycle: props.hourCycle\n        });\n\n        endFormatter = new DateFormatter(locale, endOptions);\n      }\n\n      return {\n        start: startFormatter.format(startDate),\n        end: endFormatter.format(endDate)\n      };\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}