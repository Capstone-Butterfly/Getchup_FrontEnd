{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport { TableCollection as $788781baa30117fa$export$596e1b2e2cf93690 } from \"./TableCollection.mjs\";\nimport { useTableState as $4a0dd036d492cee4$export$907bcc6c48325fd6 } from \"./useTableState.mjs\";\nimport { CollectionBuilder as $2Mvwf$CollectionBuilder } from \"@react-stately/collections\";\nimport { useMemo as $2Mvwf$useMemo } from \"react\";\nimport { tableNestedRows as $2Mvwf$tableNestedRows } from \"@react-stately/flags\";\nimport { useControlledState as $2Mvwf$useControlledState } from \"@react-stately/utils\";\nfunction $ee65a0057fd99531$export$34dfa8a1622185a4(props) {\n  let {\n    selectionMode = 'none',\n    showSelectionCheckboxes: showSelectionCheckboxes,\n    showDragButtons: showDragButtons,\n    UNSTABLE_expandedKeys: propExpandedKeys,\n    UNSTABLE_defaultExpandedKeys: propDefaultExpandedKeys,\n    UNSTABLE_onExpandedChange: UNSTABLE_onExpandedChange,\n    children: children\n  } = props;\n  if (!(0, $2Mvwf$tableNestedRows)()) throw new Error('Feature flag for table nested rows must be enabled to use useTreeGridState.');\n  let [expandedKeys, setExpandedKeys] = (0, $2Mvwf$useControlledState)(propExpandedKeys ? $ee65a0057fd99531$var$convertExpanded(propExpandedKeys) : undefined, propDefaultExpandedKeys ? $ee65a0057fd99531$var$convertExpanded(propDefaultExpandedKeys) : new Set(), UNSTABLE_onExpandedChange);\n  let context = (0, $2Mvwf$useMemo)(() => ({\n    showSelectionCheckboxes: showSelectionCheckboxes && selectionMode !== 'none',\n    showDragButtons: showDragButtons,\n    selectionMode: selectionMode,\n    columns: []\n  }), [children, showSelectionCheckboxes, selectionMode, showDragButtons]);\n  let builder = (0, $2Mvwf$useMemo)(() => new (0, $2Mvwf$CollectionBuilder)(), []);\n  let nodes = (0, $2Mvwf$useMemo)(() => builder.build({\n    children: children\n  }, context), [builder, children, context]);\n  let treeGridCollection = (0, $2Mvwf$useMemo)(() => {\n    return $ee65a0057fd99531$var$generateTreeGridCollection(nodes, {\n      showSelectionCheckboxes: showSelectionCheckboxes,\n      showDragButtons: showDragButtons,\n      expandedKeys: expandedKeys\n    });\n  }, [nodes, showSelectionCheckboxes, showDragButtons, expandedKeys]);\n  let onToggle = key => {\n    setExpandedKeys($ee65a0057fd99531$var$toggleKey(expandedKeys, key, treeGridCollection));\n  };\n  let collection = (0, $2Mvwf$useMemo)(() => {\n    return new (0, $788781baa30117fa$export$596e1b2e2cf93690)(treeGridCollection.tableNodes, null, context);\n  }, [context, treeGridCollection.tableNodes]);\n  let tableState = (0, $4a0dd036d492cee4$export$907bcc6c48325fd6)(_objectSpread(_objectSpread({}, props), {}, {\n    collection: collection\n  }));\n  return _objectSpread(_objectSpread({}, tableState), {}, {\n    keyMap: treeGridCollection.keyMap,\n    userColumnCount: treeGridCollection.userColumnCount,\n    expandedKeys: expandedKeys,\n    toggleKey: onToggle\n  });\n}\nfunction $ee65a0057fd99531$var$toggleKey(currentExpandedKeys, key, collection) {\n  let updatedExpandedKeys;\n  if (currentExpandedKeys === 'all') {\n    updatedExpandedKeys = new Set(collection.flattenedRows.filter(row => row.props.UNSTABLE_childItems || row.props.children.length > collection.userColumnCount).map(row => row.key));\n    updatedExpandedKeys.delete(key);\n  } else {\n    updatedExpandedKeys = new Set(currentExpandedKeys);\n    if (updatedExpandedKeys.has(key)) updatedExpandedKeys.delete(key);else updatedExpandedKeys.add(key);\n  }\n  return updatedExpandedKeys;\n}\nfunction $ee65a0057fd99531$var$convertExpanded(expanded) {\n  if (!expanded) return new Set();\n  return expanded === 'all' ? 'all' : new Set(expanded);\n}\nfunction $ee65a0057fd99531$var$generateTreeGridCollection(nodes, opts) {\n  let {\n    expandedKeys = new Set()\n  } = opts;\n  let body;\n  let flattenedRows = [];\n  let columnCount = 0;\n  let userColumnCount = 0;\n  let originalColumns = [];\n  let keyMap = new Map();\n  if (opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) columnCount++;\n  if (opts === null || opts === void 0 ? void 0 : opts.showDragButtons) columnCount++;\n  let topLevelRows = [];\n  let visit = node => {\n    switch (node.type) {\n      case 'body':\n        body = node;\n        keyMap.set(body.key, body);\n        break;\n      case 'column':\n        if (!node.hasChildNodes) userColumnCount++;\n        break;\n      case 'item':\n        topLevelRows.push(node);\n        return;\n    }\n    for (let child of node.childNodes) visit(child);\n  };\n  for (let node of nodes) {\n    if (node.type === 'column') originalColumns.push(node);\n    visit(node);\n  }\n  columnCount += userColumnCount;\n  let globalRowCount = 0;\n  let visitNode = (node, i) => {\n    if (node.type === 'item') {\n      let childNodes = [];\n      for (let child of node.childNodes) if (child.type === 'cell') {\n        let cellClone = _objectSpread({}, child);\n        if (cellClone.index + 1 === columnCount) cellClone.nextKey = null;\n        childNodes.push(_objectSpread({}, cellClone));\n      }\n      let clone = _objectSpread(_objectSpread({}, node), {}, {\n        childNodes: childNodes,\n        parentKey: body.key,\n        level: 1,\n        index: globalRowCount++\n      });\n      flattenedRows.push(clone);\n    }\n    let newProps = {};\n    if (node.type !== 'placeholder' && node.type !== 'column') newProps['indexOfType'] = i;\n    Object.assign(node, newProps);\n    keyMap.set(node.key, node);\n    let lastNode;\n    let rowIndex = 0;\n    for (let child of node.childNodes) if (!(child.type === 'item' && expandedKeys !== 'all' && !expandedKeys.has(node.key))) {\n      if (child.parentKey == null) child.parentKey = node.key;\n      if (lastNode) {\n        lastNode.nextKey = child.key;\n        child.prevKey = lastNode.key;\n      } else child.prevKey = null;\n      if (child.type === 'item') visitNode(child, rowIndex++);else visitNode(child, child.index);\n      lastNode = child;\n    }\n    if (lastNode) lastNode.nextKey = null;\n  };\n  let last;\n  topLevelRows.forEach((node, i) => {\n    visitNode(node, i);\n    if (last) {\n      last.nextKey = node.key;\n      node.prevKey = last.key;\n    } else node.prevKey = null;\n    last = node;\n  });\n  if (last) last.nextKey = null;\n  return {\n    keyMap: keyMap,\n    userColumnCount: userColumnCount,\n    flattenedRows: flattenedRows,\n    tableNodes: [...originalColumns, _objectSpread(_objectSpread({}, body), {}, {\n      childNodes: flattenedRows\n    })]\n  };\n}\nexport { $ee65a0057fd99531$export$34dfa8a1622185a4 as UNSTABLE_useTreeGridState };","map":{"version":3,"names":["$ee65a0057fd99531$export$34dfa8a1622185a4","props","selectionMode","showSelectionCheckboxes","showDragButtons","UNSTABLE_expandedKeys","propExpandedKeys","UNSTABLE_defaultExpandedKeys","propDefaultExpandedKeys","UNSTABLE_onExpandedChange","children","$2Mvwf$tableNestedRows","Error","expandedKeys","setExpandedKeys","$2Mvwf$useControlledState","$ee65a0057fd99531$var$convertExpanded","undefined","Set","context","$2Mvwf$useMemo","columns","builder","$2Mvwf$CollectionBuilder","nodes","build","treeGridCollection","$ee65a0057fd99531$var$generateTreeGridCollection","onToggle","key","$ee65a0057fd99531$var$toggleKey","collection","$788781baa30117fa$export$596e1b2e2cf93690","tableNodes","tableState","$4a0dd036d492cee4$export$907bcc6c48325fd6","_objectSpread","keyMap","userColumnCount","toggleKey","currentExpandedKeys","updatedExpandedKeys","flattenedRows","filter","row","UNSTABLE_childItems","length","map","delete","has","add","expanded","opts","body","columnCount","originalColumns","Map","topLevelRows","visit","node","type","set","hasChildNodes","push","child","childNodes","globalRowCount","visitNode","i","cellClone","index","nextKey","clone","parentKey","level","newProps","Object","assign","lastNode","rowIndex","prevKey","last","forEach"],"sources":["/Users/farhang/Desktop/June 17 /Front/Getchup_FrontEnd/node_modules/@react-stately/table/dist/packages/@react-stately/table/src/useTreeGridState.ts"],"sourcesContent":["/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CollectionBuilder} from '@react-stately/collections';\nimport {GridNode} from '@react-types/grid';\nimport {Key} from '@react-types/shared';\nimport {ReactElement, useMemo} from 'react';\nimport {TableCollection} from './TableCollection';\nimport {tableNestedRows} from '@react-stately/flags';\nimport {TableState, TableStateProps, useTableState} from './useTableState';\nimport {useControlledState} from '@react-stately/utils';\n\nexport interface TreeGridState<T> extends TableState<T> {\n  /** A set of keys for items that are expanded. */\n  expandedKeys: 'all' | Set<Key>,\n  /** Toggles the expanded state for a row by its key. */\n  toggleKey(key: Key): void,\n  /** The key map containing nodes representing the collection's tree grid structure. */\n  keyMap: Map<Key, GridNode<T>>,\n  /** The number of leaf columns provided by the user. */\n  userColumnCount: number\n}\n\nexport interface TreeGridStateProps<T> extends Omit<TableStateProps<T>, 'collection'> {\n  /** The currently expanded keys in the collection (controlled). */\n  UNSTABLE_expandedKeys?: 'all' | Iterable<Key>,\n  /** The initial expanded keys in the collection (uncontrolled). */\n  UNSTABLE_defaultExpandedKeys?: 'all' | Iterable<Key>,\n  /** Handler that is called when items are expanded or collapsed. */\n  UNSTABLE_onExpandedChange?: (keys: Set<Key>) => any\n}\n\n/**\n * Provides state management for a tree grid component. Handles building a collection\n * of columns and rows from props. In addition, it tracks and manages expanded rows, row selection, and sort order changes.\n */\nexport function UNSTABLE_useTreeGridState<T extends object>(props: TreeGridStateProps<T>): TreeGridState<T> {\n  let {\n    selectionMode = 'none',\n    showSelectionCheckboxes,\n    showDragButtons,\n    UNSTABLE_expandedKeys: propExpandedKeys,\n    UNSTABLE_defaultExpandedKeys: propDefaultExpandedKeys,\n    UNSTABLE_onExpandedChange,\n    children\n  } = props;\n\n  if (!tableNestedRows()) {\n    throw new Error('Feature flag for table nested rows must be enabled to use useTreeGridState.');\n  }\n\n  let [expandedKeys, setExpandedKeys] = useControlledState(\n    propExpandedKeys ? convertExpanded(propExpandedKeys) : undefined,\n    propDefaultExpandedKeys ? convertExpanded(propDefaultExpandedKeys) : new Set(),\n    UNSTABLE_onExpandedChange\n  );\n\n  let context = useMemo(() => ({\n    showSelectionCheckboxes: showSelectionCheckboxes && selectionMode !== 'none',\n    showDragButtons: showDragButtons,\n    selectionMode,\n    columns: []\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }), [children, showSelectionCheckboxes, selectionMode, showDragButtons]);\n\n  let builder = useMemo(() => new CollectionBuilder<T>(), []);\n  let nodes = useMemo(() => builder.build({children: children as ReactElement[]}, context), [builder, children, context]);\n  let treeGridCollection = useMemo(() => {\n    return generateTreeGridCollection<T>(nodes, {showSelectionCheckboxes, showDragButtons, expandedKeys});\n  }, [nodes, showSelectionCheckboxes, showDragButtons, expandedKeys]);\n\n  let onToggle = (key: Key) => {\n    setExpandedKeys(toggleKey(expandedKeys, key, treeGridCollection));\n  };\n\n  let collection = useMemo(() => {\n    return new TableCollection(treeGridCollection.tableNodes, null, context);\n  }, [context, treeGridCollection.tableNodes]);\n\n  let tableState = useTableState({...props, collection});\n  return {\n    ...tableState,\n    keyMap: treeGridCollection.keyMap,\n    userColumnCount: treeGridCollection.userColumnCount,\n    expandedKeys,\n    toggleKey: onToggle\n  };\n}\n\nfunction toggleKey<T>(currentExpandedKeys: 'all' | Set<Key>, key: Key, collection: TreeGridCollection<T>): Set<Key> {\n  let updatedExpandedKeys: Set<Key>;\n  if (currentExpandedKeys === 'all') {\n    updatedExpandedKeys = new Set(collection.flattenedRows.filter(row => row.props.UNSTABLE_childItems || row.props.children.length > collection.userColumnCount).map(row => row.key));\n    updatedExpandedKeys.delete(key);\n  } else {\n    updatedExpandedKeys = new Set(currentExpandedKeys);\n    if (updatedExpandedKeys.has(key)) {\n      updatedExpandedKeys.delete(key);\n    } else {\n      updatedExpandedKeys.add(key);\n    }\n  }\n\n  return updatedExpandedKeys;\n}\n\nfunction convertExpanded(expanded: 'all' | Iterable<Key>): 'all' | Set<Key> {\n  if (!expanded) {\n    return new Set<Key>();\n  }\n\n  return expanded === 'all'\n    ? 'all'\n    : new Set(expanded);\n}\n\ninterface TreeGridCollectionOptions {\n  showSelectionCheckboxes?: boolean,\n  showDragButtons?: boolean,\n  expandedKeys: 'all' | Set<Key>\n}\n\ninterface TreeGridCollection<T> {\n  keyMap: Map<Key, GridNode<T>>,\n  tableNodes: GridNode<T>[],\n  flattenedRows: GridNode<T>[],\n  userColumnCount: number\n}\nfunction generateTreeGridCollection<T>(nodes, opts: TreeGridCollectionOptions): TreeGridCollection<T> {\n  let {\n    expandedKeys = new Set()\n  } = opts;\n\n  let body: GridNode<T>;\n  let flattenedRows = [];\n  let columnCount = 0;\n  let userColumnCount = 0;\n  let originalColumns = [];\n  let keyMap = new Map();\n\n  if (opts?.showSelectionCheckboxes) {\n    columnCount++;\n  }\n\n  if (opts?.showDragButtons) {\n    columnCount++;\n  }\n\n  let topLevelRows = [];\n  let visit = (node: GridNode<T>) => {\n    switch (node.type) {\n      case 'body':\n        body = node;\n        keyMap.set(body.key, body);\n        break;\n      case 'column':\n        if (!node.hasChildNodes) {\n          userColumnCount++;\n        }\n        break;\n      case 'item':\n        topLevelRows.push(node);\n        return;\n    }\n\n    for (let child of node.childNodes) {\n      visit(child);\n    }\n  };\n\n  for (let node of nodes) {\n    if (node.type === 'column') {\n      originalColumns.push(node);\n    }\n    visit(node);\n  }\n  columnCount += userColumnCount;\n\n  // Update each grid node in the treegrid table with values specific to a treegrid structure. Also store a set of flattened row nodes for TableCollection to consume\n  let globalRowCount = 0;\n  let visitNode = (node: GridNode<T>, i?: number) => {\n    // Clone row node and its children so modifications to the node for treegrid specific values aren't applied on the nodes provided\n    // to TableCollection. Index, level, and parent keys are all changed to reflect a flattened row structure rather than the treegrid structure\n    // values automatically calculated via CollectionBuilder\n    if (node.type === 'item') {\n      let childNodes = [];\n      for (let child of node.childNodes) {\n        if (child.type === 'cell') {\n          let cellClone = {...child};\n          if (cellClone.index + 1 === columnCount) {\n            cellClone.nextKey = null;\n          }\n          childNodes.push({...cellClone});\n        }\n      }\n      let clone = {...node, childNodes: childNodes, parentKey: body.key, level: 1, index: globalRowCount++};\n      flattenedRows.push(clone);\n    }\n\n    let newProps = {};\n\n    // Assign indexOfType to cells and rows for aria-posinset\n    if (node.type !== 'placeholder' && node.type !== 'column') {\n      newProps['indexOfType'] = i;\n    }\n\n    // Use Object.assign instead of spread to preserve object reference for keyMap. Also ensures retrieving nodes\n    // via .childNodes returns the same object as the one found via keyMap look up\n    Object.assign(node, newProps);\n    keyMap.set(node.key, node);\n\n    let lastNode: GridNode<T>;\n    let rowIndex = 0;\n    for (let child of node.childNodes) {\n      if (!(child.type === 'item' && expandedKeys !== 'all' && !expandedKeys.has(node.key))) {\n        if (child.parentKey == null) {\n          // if child is a cell/expanded row/column and the parent key isn't already established by the collection, match child node to parent row\n          child.parentKey = node.key;\n        }\n\n        if (lastNode) {\n          lastNode.nextKey = child.key;\n          child.prevKey = lastNode.key;\n        } else {\n          child.prevKey = null;\n        }\n\n        if (child.type === 'item') {\n          visitNode(child, rowIndex++);\n        } else {\n          // We enforce that the cells come before rows so can just reuse cell index\n          visitNode(child, child.index);\n        }\n\n        lastNode = child;\n      }\n    }\n\n    if (lastNode) {\n      lastNode.nextKey = null;\n    }\n  };\n\n  let last: GridNode<T>;\n  topLevelRows.forEach((node: GridNode<T>, i) => {\n    visitNode(node as GridNode<T>, i);\n\n    if (last) {\n      last.nextKey = node.key;\n      node.prevKey = last.key;\n    } else {\n      node.prevKey = null;\n    }\n\n    last = node;\n  });\n\n  if (last) {\n    last.nextKey = null;\n  }\n\n  return {\n    keyMap,\n    userColumnCount,\n    flattenedRows,\n    tableNodes: [...originalColumns, {...body, childNodes: flattenedRows}]\n  };\n}\n"],"mappings":";;;;;;;;;AA6CO,SAASA,0CAA4CC,KAA4B;EACtF,IAAI;IACFC,aAAA,GAAgB;IAAAC,uBAAA,EAChBA,uBAAuB;IAAAC,eAAA,EACvBA,eAAe;IACfC,qBAAA,EAAuBC,gBAAgB;IACvCC,4BAAA,EAA8BC,uBAAuB;IAAAC,yBAAA,EACrDA,yBAAyB;IAAAC,QAAA,EACzBA;EAAQ,CACT,GAAGT,KAAA;EAEJ,IAAI,CAAC,IAAAU,sBAAc,KACjB,MAAM,IAAIC,KAAA,CAAM;EAGlB,IAAI,CAACC,YAAA,EAAcC,eAAA,CAAgB,GAAG,IAAAC,yBAAiB,EACrDT,gBAAA,GAAmBU,qCAAA,CAAgBV,gBAAA,IAAoBW,SAAA,EACvDT,uBAAA,GAA0BQ,qCAAA,CAAgBR,uBAAA,IAA2B,IAAIU,GAAA,IACzET,yBAAA;EAGF,IAAIU,OAAA,GAAU,IAAAC,cAAM,EAAE,OAAO;IAC3BjB,uBAAA,EAAyBA,uBAAA,IAA2BD,aAAA,KAAkB;IACtEE,eAAA,EAAiBA,eAAA;mBACjBF,aAAA;IACAmB,OAAA,EAAS;EAEX,IAAI,CAACX,QAAA,EAAUP,uBAAA,EAAyBD,aAAA,EAAeE,eAAA,CAAgB;EAEvE,IAAIkB,OAAA,GAAU,IAAAF,cAAM,EAAE,MAAM,KAAI,GAAAG,wBAAgB,KAAQ,EAAE;EAC1D,IAAIC,KAAA,GAAQ,IAAAJ,cAAM,EAAE,MAAME,OAAA,CAAQG,KAAK,CAAC;IAACf,QAAA,EAAUA;EAA0B,GAAGS,OAAA,GAAU,CAACG,OAAA,EAASZ,QAAA,EAAUS,OAAA,CAAQ;EACtH,IAAIO,kBAAA,GAAqB,IAAAN,cAAM,EAAE;IAC/B,OAAOO,gDAAA,CAA8BH,KAAA,EAAO;+BAACrB,uBAAA;uBAAyBC,eAAA;oBAAiBS;IAAY;EACrG,GAAG,CAACW,KAAA,EAAOrB,uBAAA,EAAyBC,eAAA,EAAiBS,YAAA,CAAa;EAElE,IAAIe,QAAA,GAAYC,GAAA;IACdf,eAAA,CAAgBgB,+BAAA,CAAUjB,YAAA,EAAcgB,GAAA,EAAKH,kBAAA;EAC/C;EAEA,IAAIK,UAAA,GAAa,IAAAX,cAAM,EAAE;IACvB,OAAO,KAAI,GAAAY,yCAAc,EAAEN,kBAAA,CAAmBO,UAAU,EAAE,MAAMd,OAAA;EAClE,GAAG,CAACA,OAAA,EAASO,kBAAA,CAAmBO,UAAU,CAAC;EAE3C,IAAIC,UAAA,GAAa,IAAAC,yCAAY,EAAAC,aAAA,CAAAA,aAAA,KAAMnC,KAAK;gBAAE8B;EAAA,EAAU;EACpD,OAAAK,aAAA,CAAAA,aAAA,KACKF,UAAU;IACbG,MAAA,EAAQX,kBAAA,CAAmBW,MAAM;IACjCC,eAAA,EAAiBZ,kBAAA,CAAmBY,eAAe;kBACnDzB,YAAA;IACA0B,SAAA,EAAWX;EAAA;AAEf;AAEA,SAASE,gCAAaU,mBAAqC,EAAEX,GAAQ,EAAEE,UAAiC;EACtG,IAAIU,mBAAA;EACJ,IAAID,mBAAA,KAAwB,OAAO;IACjCC,mBAAA,GAAsB,IAAIvB,GAAA,CAAIa,UAAA,CAAWW,aAAa,CAACC,MAAM,CAACC,GAAA,IAAOA,GAAA,CAAI3C,KAAK,CAAC4C,mBAAmB,IAAID,GAAA,CAAI3C,KAAK,CAACS,QAAQ,CAACoC,MAAM,GAAGf,UAAA,CAAWO,eAAe,EAAES,GAAG,CAACH,GAAA,IAAOA,GAAA,CAAIf,GAAG;IAChLY,mBAAA,CAAoBO,MAAM,CAACnB,GAAA;EAC7B,OAAO;IACLY,mBAAA,GAAsB,IAAIvB,GAAA,CAAIsB,mBAAA;IAC9B,IAAIC,mBAAA,CAAoBQ,GAAG,CAACpB,GAAA,GAC1BY,mBAAA,CAAoBO,MAAM,CAACnB,GAAA,OAE3BY,mBAAA,CAAoBS,GAAG,CAACrB,GAAA;EAE5B;EAEA,OAAOY,mBAAA;AACT;AAEA,SAASzB,sCAAgBmC,QAA+B;EACtD,IAAI,CAACA,QAAA,EACH,OAAO,IAAIjC,GAAA;EAGb,OAAOiC,QAAA,KAAa,QAChB,QACA,IAAIjC,GAAA,CAAIiC,QAAA;AACd;AAcA,SAASxB,iDAA8BH,KAAK,EAAE4B,IAA+B;EAC3E,IAAI;IACFvC,YAAA,GAAe,IAAIK,GAAA;EAAA,CACpB,GAAGkC,IAAA;EAEJ,IAAIC,IAAA;EACJ,IAAIX,aAAA,GAAgB,EAAE;EACtB,IAAIY,WAAA,GAAc;EAClB,IAAIhB,eAAA,GAAkB;EACtB,IAAIiB,eAAA,GAAkB,EAAE;EACxB,IAAIlB,MAAA,GAAS,IAAImB,GAAA;EAEjB,IAAIJ,IAAA,aAAAA,IAAA,uBAAAA,IAAA,CAAMjD,uBAAuB,EAC/BmD,WAAA;EAGF,IAAIF,IAAA,aAAAA,IAAA,uBAAAA,IAAA,CAAMhD,eAAe,EACvBkD,WAAA;EAGF,IAAIG,YAAA,GAAe,EAAE;EACrB,IAAIC,KAAA,GAASC,IAAA;IACX,QAAQA,IAAA,CAAKC,IAAI;MACf,KAAK;QACHP,IAAA,GAAOM,IAAA;QACPtB,MAAA,CAAOwB,GAAG,CAACR,IAAA,CAAKxB,GAAG,EAAEwB,IAAA;QACrB;MACF,KAAK;QACH,IAAI,CAACM,IAAA,CAAKG,aAAa,EACrBxB,eAAA;QAEF;MACF,KAAK;QACHmB,YAAA,CAAaM,IAAI,CAACJ,IAAA;QAClB;IACJ;IAEA,KAAK,IAAIK,KAAA,IAASL,IAAA,CAAKM,UAAU,EAC/BP,KAAA,CAAMM,KAAA;EAEV;EAEA,KAAK,IAAIL,IAAA,IAAQnC,KAAA,EAAO;IACtB,IAAImC,IAAA,CAAKC,IAAI,KAAK,UAChBL,eAAA,CAAgBQ,IAAI,CAACJ,IAAA;IAEvBD,KAAA,CAAMC,IAAA;EACR;EACAL,WAAA,IAAehB,eAAA;EAGf,IAAI4B,cAAA,GAAiB;EACrB,IAAIC,SAAA,GAAYA,CAACR,IAAA,EAAmBS,CAAA;IAIlC,IAAIT,IAAA,CAAKC,IAAI,KAAK,QAAQ;MACxB,IAAIK,UAAA,GAAa,EAAE;MACnB,KAAK,IAAID,KAAA,IAASL,IAAA,CAAKM,UAAU,EAC/B,IAAID,KAAA,CAAMJ,IAAI,KAAK,QAAQ;QACzB,IAAIS,SAAA,GAAAjC,aAAA,KAAgB4B,KAAK;QACzB,IAAIK,SAAA,CAAUC,KAAK,GAAG,MAAMhB,WAAA,EAC1Be,SAAA,CAAUE,OAAO,GAAG;QAEtBN,UAAA,CAAWF,IAAI,CAAA3B,aAAA,KAAKiC,SAAS;MAC/B;MAEF,IAAIG,KAAA,GAAApC,aAAA,CAAAA,aAAA,KAAYuB,IAAI;QAAEM,UAAA,EAAYA,UAAA;QAAYQ,SAAA,EAAWpB,IAAA,CAAKxB,GAAG;QAAE6C,KAAA,EAAO;QAAGJ,KAAA,EAAOJ,cAAA;MAAA,EAAgB;MACpGxB,aAAA,CAAcqB,IAAI,CAACS,KAAA;IACrB;IAEA,IAAIG,QAAA,GAAW,CAAC;IAGhB,IAAIhB,IAAA,CAAKC,IAAI,KAAK,iBAAiBD,IAAA,CAAKC,IAAI,KAAK,UAC/Ce,QAAQ,CAAC,cAAc,GAAGP,CAAA;IAK5BQ,MAAA,CAAOC,MAAM,CAAClB,IAAA,EAAMgB,QAAA;IACpBtC,MAAA,CAAOwB,GAAG,CAACF,IAAA,CAAK9B,GAAG,EAAE8B,IAAA;IAErB,IAAImB,QAAA;IACJ,IAAIC,QAAA,GAAW;IACf,KAAK,IAAIf,KAAA,IAASL,IAAA,CAAKM,UAAU,EAC/B,IAAI,EAAED,KAAA,CAAMJ,IAAI,KAAK,UAAU/C,YAAA,KAAiB,SAAS,CAACA,YAAA,CAAaoC,GAAG,CAACU,IAAA,CAAK9B,GAAG,IAAI;MACrF,IAAImC,KAAA,CAAMS,SAAS,IAAI,MAErBT,KAAA,CAAMS,SAAS,GAAGd,IAAA,CAAK9B,GAAG;MAG5B,IAAIiD,QAAA,EAAU;QACZA,QAAA,CAASP,OAAO,GAAGP,KAAA,CAAMnC,GAAG;QAC5BmC,KAAA,CAAMgB,OAAO,GAAGF,QAAA,CAASjD,GAAG;MAC9B,OACEmC,KAAA,CAAMgB,OAAO,GAAG;MAGlB,IAAIhB,KAAA,CAAMJ,IAAI,KAAK,QACjBO,SAAA,CAAUH,KAAA,EAAOe,QAAA,SAGjBZ,SAAA,CAAUH,KAAA,EAAOA,KAAA,CAAMM,KAAK;MAG9BQ,QAAA,GAAWd,KAAA;IACb;IAGF,IAAIc,QAAA,EACFA,QAAA,CAASP,OAAO,GAAG;EAEvB;EAEA,IAAIU,IAAA;EACJxB,YAAA,CAAayB,OAAO,CAAC,CAACvB,IAAA,EAAmBS,CAAA;IACvCD,SAAA,CAAUR,IAAA,EAAqBS,CAAA;IAE/B,IAAIa,IAAA,EAAM;MACRA,IAAA,CAAKV,OAAO,GAAGZ,IAAA,CAAK9B,GAAG;MACvB8B,IAAA,CAAKqB,OAAO,GAAGC,IAAA,CAAKpD,GAAG;IACzB,OACE8B,IAAA,CAAKqB,OAAO,GAAG;IAGjBC,IAAA,GAAOtB,IAAA;EACT;EAEA,IAAIsB,IAAA,EACFA,IAAA,CAAKV,OAAO,GAAG;EAGjB,OAAO;YACLlC,MAAA;qBACAC,eAAA;mBACAI,aAAA;IACAT,UAAA,EAAY,C,GAAIsB,eAAA,EAAAnB,aAAA,CAAAA,aAAA,KAAqBiB,IAAI;MAAEY,UAAA,EAAYvB;IAAA;EACzD;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}