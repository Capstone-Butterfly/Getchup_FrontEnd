{"ast":null,"code":"import { Selection as $e40ea825a81a3709$export$52baac22726c72bf } from \"./Selection.mjs\";\nimport { compareNodeOrder as $jkhUT$compareNodeOrder, getFirstItem as $jkhUT$getFirstItem, getChildNodes as $jkhUT$getChildNodes } from \"@react-stately/collections\";\nclass $d496c0a20b6e58ec$export$6c8a5aaad13c9852 {\n  get selectionMode() {\n    return this.state.selectionMode;\n  }\n  get disallowEmptySelection() {\n    return this.state.disallowEmptySelection;\n  }\n  get selectionBehavior() {\n    return this.state.selectionBehavior;\n  }\n  setSelectionBehavior(selectionBehavior) {\n    this.state.setSelectionBehavior(selectionBehavior);\n  }\n  get isFocused() {\n    return this.state.isFocused;\n  }\n  setFocused(isFocused) {\n    this.state.setFocused(isFocused);\n  }\n  get focusedKey() {\n    return this.state.focusedKey;\n  }\n  get childFocusStrategy() {\n    return this.state.childFocusStrategy;\n  }\n  setFocusedKey(key, childFocusStrategy) {\n    if (key == null || this.collection.getItem(key)) this.state.setFocusedKey(key, childFocusStrategy);\n  }\n  get selectedKeys() {\n    return this.state.selectedKeys === 'all' ? new Set(this.getSelectAllKeys()) : this.state.selectedKeys;\n  }\n  get rawSelection() {\n    return this.state.selectedKeys;\n  }\n  isSelected(key) {\n    if (this.state.selectionMode === 'none') return false;\n    key = this.getKey(key);\n    return this.state.selectedKeys === 'all' ? this.canSelectItem(key) : this.state.selectedKeys.has(key);\n  }\n  get isEmpty() {\n    return this.state.selectedKeys !== 'all' && this.state.selectedKeys.size === 0;\n  }\n  get isSelectAll() {\n    if (this.isEmpty) return false;\n    if (this.state.selectedKeys === 'all') return true;\n    if (this._isSelectAll != null) return this._isSelectAll;\n    let allKeys = this.getSelectAllKeys();\n    let selectedKeys = this.state.selectedKeys;\n    this._isSelectAll = allKeys.every(k => selectedKeys.has(k));\n    return this._isSelectAll;\n  }\n  get firstSelectedKey() {\n    let first = null;\n    for (let key of this.state.selectedKeys) {\n      let item = this.collection.getItem(key);\n      if (!first || item && (0, $jkhUT$compareNodeOrder)(this.collection, item, first) < 0) first = item;\n    }\n    return first === null || first === void 0 ? void 0 : first.key;\n  }\n  get lastSelectedKey() {\n    let last = null;\n    for (let key of this.state.selectedKeys) {\n      let item = this.collection.getItem(key);\n      if (!last || item && (0, $jkhUT$compareNodeOrder)(this.collection, item, last) > 0) last = item;\n    }\n    return last === null || last === void 0 ? void 0 : last.key;\n  }\n  get disabledKeys() {\n    return this.state.disabledKeys;\n  }\n  get disabledBehavior() {\n    return this.state.disabledBehavior;\n  }\n  extendSelection(toKey) {\n    if (this.selectionMode === 'none') return;\n    if (this.selectionMode === 'single') {\n      this.replaceSelection(toKey);\n      return;\n    }\n    toKey = this.getKey(toKey);\n    let selection;\n    if (this.state.selectedKeys === 'all') selection = new (0, $e40ea825a81a3709$export$52baac22726c72bf)([toKey], toKey, toKey);else {\n      let selectedKeys = this.state.selectedKeys;\n      let anchorKey = selectedKeys.anchorKey || toKey;\n      selection = new (0, $e40ea825a81a3709$export$52baac22726c72bf)(selectedKeys, anchorKey, toKey);\n      for (let key of this.getKeyRange(anchorKey, selectedKeys.currentKey || toKey)) selection.delete(key);\n      for (let key of this.getKeyRange(toKey, anchorKey)) if (this.canSelectItem(key)) selection.add(key);\n    }\n    this.state.setSelectedKeys(selection);\n  }\n  getKeyRange(from, to) {\n    let fromItem = this.collection.getItem(from);\n    let toItem = this.collection.getItem(to);\n    if (fromItem && toItem) {\n      if ((0, $jkhUT$compareNodeOrder)(this.collection, fromItem, toItem) <= 0) return this.getKeyRangeInternal(from, to);\n      return this.getKeyRangeInternal(to, from);\n    }\n    return [];\n  }\n  getKeyRangeInternal(from, to) {\n    let keys = [];\n    let key = from;\n    while (key) {\n      let item = this.collection.getItem(key);\n      if (item && item.type === 'item' || item.type === 'cell' && this.allowsCellSelection) keys.push(key);\n      if (key === to) return keys;\n      key = this.collection.getKeyAfter(key);\n    }\n    return [];\n  }\n  getKey(key) {\n    let item = this.collection.getItem(key);\n    if (!item) return key;\n    if (item.type === 'cell' && this.allowsCellSelection) return key;\n    while (item.type !== 'item' && item.parentKey != null) item = this.collection.getItem(item.parentKey);\n    if (!item || item.type !== 'item') return null;\n    return item.key;\n  }\n  toggleSelection(key) {\n    if (this.selectionMode === 'none') return;\n    if (this.selectionMode === 'single' && !this.isSelected(key)) {\n      this.replaceSelection(key);\n      return;\n    }\n    key = this.getKey(key);\n    if (key == null) return;\n    let keys = new (0, $e40ea825a81a3709$export$52baac22726c72bf)(this.state.selectedKeys === 'all' ? this.getSelectAllKeys() : this.state.selectedKeys);\n    if (keys.has(key)) keys.delete(key);else if (this.canSelectItem(key)) {\n      keys.add(key);\n      keys.anchorKey = key;\n      keys.currentKey = key;\n    }\n    if (this.disallowEmptySelection && keys.size === 0) return;\n    this.state.setSelectedKeys(keys);\n  }\n  replaceSelection(key) {\n    if (this.selectionMode === 'none') return;\n    key = this.getKey(key);\n    if (key == null) return;\n    let selection = this.canSelectItem(key) ? new (0, $e40ea825a81a3709$export$52baac22726c72bf)([key], key, key) : new (0, $e40ea825a81a3709$export$52baac22726c72bf)();\n    this.state.setSelectedKeys(selection);\n  }\n  setSelectedKeys(keys) {\n    if (this.selectionMode === 'none') return;\n    let selection = new (0, $e40ea825a81a3709$export$52baac22726c72bf)();\n    for (let key of keys) {\n      key = this.getKey(key);\n      if (key != null) {\n        selection.add(key);\n        if (this.selectionMode === 'single') break;\n      }\n    }\n    this.state.setSelectedKeys(selection);\n  }\n  getSelectAllKeys() {\n    let keys = [];\n    let addKeys = key => {\n      while (key) {\n        if (this.canSelectItem(key)) {\n          let item = this.collection.getItem(key);\n          if (item.type === 'item') keys.push(key);\n          if (item.hasChildNodes && (this.allowsCellSelection || item.type !== 'item')) addKeys((0, $jkhUT$getFirstItem)((0, $jkhUT$getChildNodes)(item, this.collection)).key);\n        }\n        key = this.collection.getKeyAfter(key);\n      }\n    };\n    addKeys(this.collection.getFirstKey());\n    return keys;\n  }\n  selectAll() {\n    if (!this.isSelectAll && this.selectionMode === 'multiple') this.state.setSelectedKeys('all');\n  }\n  clearSelection() {\n    if (!this.disallowEmptySelection && (this.state.selectedKeys === 'all' || this.state.selectedKeys.size > 0)) this.state.setSelectedKeys(new (0, $e40ea825a81a3709$export$52baac22726c72bf)());\n  }\n  toggleSelectAll() {\n    if (this.isSelectAll) this.clearSelection();else this.selectAll();\n  }\n  select(key, e) {\n    if (this.selectionMode === 'none') return;\n    if (this.selectionMode === 'single') {\n      if (this.isSelected(key) && !this.disallowEmptySelection) this.toggleSelection(key);else this.replaceSelection(key);\n    } else if (this.selectionBehavior === 'toggle' || e && (e.pointerType === 'touch' || e.pointerType === 'virtual')) this.toggleSelection(key);else this.replaceSelection(key);\n  }\n  isSelectionEqual(selection) {\n    if (selection === this.state.selectedKeys) return true;\n    let selectedKeys = this.selectedKeys;\n    if (selection.size !== selectedKeys.size) return false;\n    for (let key of selection) {\n      if (!selectedKeys.has(key)) return false;\n    }\n    for (let key of selectedKeys) {\n      if (!selection.has(key)) return false;\n    }\n    return true;\n  }\n  canSelectItem(key) {\n    var _item_props;\n    if (this.state.selectionMode === 'none' || this.state.disabledKeys.has(key)) return false;\n    let item = this.collection.getItem(key);\n    if (!item || (item === null || item === void 0 ? void 0 : (_item_props = item.props) === null || _item_props === void 0 ? void 0 : _item_props.isDisabled) || item.type === 'cell' && !this.allowsCellSelection) return false;\n    return true;\n  }\n  isDisabled(key) {\n    var _this_collection_getItem_props, _this_collection_getItem;\n    return this.state.disabledBehavior === 'all' && (this.state.disabledKeys.has(key) || !!((_this_collection_getItem = this.collection.getItem(key)) === null || _this_collection_getItem === void 0 ? void 0 : (_this_collection_getItem_props = _this_collection_getItem.props) === null || _this_collection_getItem_props === void 0 ? void 0 : _this_collection_getItem_props.isDisabled));\n  }\n  isLink(key) {\n    var _this_collection_getItem_props, _this_collection_getItem;\n    return !!((_this_collection_getItem = this.collection.getItem(key)) === null || _this_collection_getItem === void 0 ? void 0 : (_this_collection_getItem_props = _this_collection_getItem.props) === null || _this_collection_getItem_props === void 0 ? void 0 : _this_collection_getItem_props.href);\n  }\n  getItemProps(key) {\n    var _this_collection_getItem;\n    return (_this_collection_getItem = this.collection.getItem(key)) === null || _this_collection_getItem === void 0 ? void 0 : _this_collection_getItem.props;\n  }\n  constructor(collection, state, options) {\n    this.collection = collection;\n    this.state = state;\n    var _options_allowsCellSelection;\n    this.allowsCellSelection = (_options_allowsCellSelection = options === null || options === void 0 ? void 0 : options.allowsCellSelection) !== null && _options_allowsCellSelection !== void 0 ? _options_allowsCellSelection : false;\n    this._isSelectAll = null;\n  }\n}\nexport { $d496c0a20b6e58ec$export$6c8a5aaad13c9852 as SelectionManager };","map":{"version":3,"names":["$d496c0a20b6e58ec$export$6c8a5aaad13c9852","selectionMode","state","disallowEmptySelection","selectionBehavior","setSelectionBehavior","isFocused","setFocused","focusedKey","childFocusStrategy","setFocusedKey","key","collection","getItem","selectedKeys","Set","getSelectAllKeys","rawSelection","isSelected","getKey","canSelectItem","has","isEmpty","size","isSelectAll","_isSelectAll","allKeys","every","k","firstSelectedKey","first","item","$jkhUT$compareNodeOrder","lastSelectedKey","last","disabledKeys","disabledBehavior","extendSelection","toKey","replaceSelection","selection","$e40ea825a81a3709$export$52baac22726c72bf","anchorKey","getKeyRange","currentKey","delete","add","setSelectedKeys","from","to","fromItem","toItem","getKeyRangeInternal","keys","type","allowsCellSelection","push","getKeyAfter","parentKey","toggleSelection","addKeys","hasChildNodes","$jkhUT$getFirstItem","$jkhUT$getChildNodes","getFirstKey","selectAll","clearSelection","toggleSelectAll","select","e","pointerType","isSelectionEqual","_item_props","props","isDisabled","_this_collection_getItem_props","_this_collection_getItem","isLink","href","getItemProps","constructor","options","_options_allowsCellSelection"],"sources":["/Users/farhang/Desktop/June 17 /Front/Getchup_FrontEnd/node_modules/@react-stately/selection/dist/packages/@react-stately/selection/src/SelectionManager.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {\n  Collection, DisabledBehavior,\n  FocusStrategy,\n  Selection as ISelection,\n  Key,\n  LongPressEvent,\n  Node,\n  PressEvent,\n  SelectionBehavior,\n  SelectionMode\n} from '@react-types/shared';\nimport {compareNodeOrder, getChildNodes, getFirstItem} from '@react-stately/collections';\nimport {MultipleSelectionManager, MultipleSelectionState} from './types';\nimport {Selection} from './Selection';\n\ninterface SelectionManagerOptions {\n  allowsCellSelection?: boolean\n}\n\n/**\n * An interface for reading and updating multiple selection state.\n */\nexport class SelectionManager implements MultipleSelectionManager {\n  private collection: Collection<Node<unknown>>;\n  private state: MultipleSelectionState;\n  private allowsCellSelection: boolean;\n  private _isSelectAll: boolean;\n\n  constructor(collection: Collection<Node<unknown>>, state: MultipleSelectionState, options?: SelectionManagerOptions) {\n    this.collection = collection;\n    this.state = state;\n    this.allowsCellSelection = options?.allowsCellSelection ?? false;\n    this._isSelectAll = null;\n  }\n\n  /**\n   * The type of selection that is allowed in the collection.\n   */\n  get selectionMode(): SelectionMode {\n    return this.state.selectionMode;\n  }\n\n  /**\n   * Whether the collection allows empty selection.\n   */\n  get disallowEmptySelection(): boolean {\n    return this.state.disallowEmptySelection;\n  }\n\n  /**\n   * The selection behavior for the collection.\n   */\n  get selectionBehavior(): SelectionBehavior {\n    return this.state.selectionBehavior;\n  }\n\n  /**\n   * Sets the selection behavior for the collection.\n   */\n  setSelectionBehavior(selectionBehavior: SelectionBehavior) {\n    this.state.setSelectionBehavior(selectionBehavior);\n  }\n\n  /**\n   * Whether the collection is currently focused.\n   */\n  get isFocused(): boolean {\n    return this.state.isFocused;\n  }\n\n  /**\n   * Sets whether the collection is focused.\n   */\n  setFocused(isFocused: boolean) {\n    this.state.setFocused(isFocused);\n  }\n\n  /**\n   * The current focused key in the collection.\n   */\n  get focusedKey(): Key {\n    return this.state.focusedKey;\n  }\n\n  /** Whether the first or last child of the focused key should receive focus. */\n  get childFocusStrategy(): FocusStrategy {\n    return this.state.childFocusStrategy;\n  }\n\n  /**\n   * Sets the focused key.\n   */\n  setFocusedKey(key: Key | null, childFocusStrategy?: FocusStrategy) {\n    if (key == null || this.collection.getItem(key)) {\n      this.state.setFocusedKey(key, childFocusStrategy);\n    }\n  }\n\n  /**\n   * The currently selected keys in the collection.\n   */\n  get selectedKeys(): Set<Key> {\n    return this.state.selectedKeys === 'all'\n      ? new Set(this.getSelectAllKeys())\n      : this.state.selectedKeys;\n  }\n\n  /**\n   * The raw selection value for the collection.\n   * Either 'all' for select all, or a set of keys.\n   */\n  get rawSelection(): ISelection {\n    return this.state.selectedKeys;\n  }\n\n  /**\n   * Returns whether a key is selected.\n   */\n  isSelected(key: Key) {\n    if (this.state.selectionMode === 'none') {\n      return false;\n    }\n\n    key = this.getKey(key);\n    return this.state.selectedKeys === 'all'\n      ? this.canSelectItem(key)\n      : this.state.selectedKeys.has(key);\n  }\n\n  /**\n   * Whether the selection is empty.\n   */\n  get isEmpty(): boolean {\n    return this.state.selectedKeys !== 'all' && this.state.selectedKeys.size === 0;\n  }\n\n  /**\n   * Whether all items in the collection are selected.\n   */\n  get isSelectAll(): boolean {\n    if (this.isEmpty) {\n      return false;\n    }\n\n    if (this.state.selectedKeys === 'all') {\n      return true;\n    }\n\n    if (this._isSelectAll != null) {\n      return this._isSelectAll;\n    }\n\n    let allKeys = this.getSelectAllKeys();\n    let selectedKeys = this.state.selectedKeys;\n    this._isSelectAll = allKeys.every(k => selectedKeys.has(k));\n    return this._isSelectAll;\n  }\n\n  get firstSelectedKey(): Key | null {\n    let first: Node<unknown> | null = null;\n    for (let key of this.state.selectedKeys) {\n      let item = this.collection.getItem(key);\n      if (!first || (item && compareNodeOrder(this.collection, item, first) < 0)) {\n        first = item;\n      }\n    }\n\n    return first?.key;\n  }\n\n  get lastSelectedKey(): Key | null {\n    let last: Node<unknown> | null = null;\n    for (let key of this.state.selectedKeys) {\n      let item = this.collection.getItem(key);\n      if (!last || (item && compareNodeOrder(this.collection, item, last) > 0)) {\n        last = item;\n      }\n    }\n\n    return last?.key;\n  }\n\n  get disabledKeys(): Set<Key> {\n    return this.state.disabledKeys;\n  }\n\n  get disabledBehavior(): DisabledBehavior {\n    return this.state.disabledBehavior;\n  }\n\n  /**\n   * Extends the selection to the given key.\n   */\n  extendSelection(toKey: Key) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    if (this.selectionMode === 'single') {\n      this.replaceSelection(toKey);\n      return;\n    }\n\n    toKey = this.getKey(toKey);\n\n    let selection: Selection;\n\n    // Only select the one key if coming from a select all.\n    if (this.state.selectedKeys === 'all') {\n      selection = new Selection([toKey], toKey, toKey);\n    } else {\n      let selectedKeys = this.state.selectedKeys as Selection;\n      let anchorKey = selectedKeys.anchorKey || toKey;\n      selection = new Selection(selectedKeys, anchorKey, toKey);\n      for (let key of this.getKeyRange(anchorKey, selectedKeys.currentKey || toKey)) {\n        selection.delete(key);\n      }\n\n      for (let key of this.getKeyRange(toKey, anchorKey)) {\n        if (this.canSelectItem(key)) {\n          selection.add(key);\n        }\n      }\n    }\n\n    this.state.setSelectedKeys(selection);\n  }\n\n  private getKeyRange(from: Key, to: Key) {\n    let fromItem = this.collection.getItem(from);\n    let toItem = this.collection.getItem(to);\n    if (fromItem && toItem) {\n      if (compareNodeOrder(this.collection, fromItem, toItem) <= 0) {\n        return this.getKeyRangeInternal(from, to);\n      }\n\n      return this.getKeyRangeInternal(to, from);\n    }\n\n    return [];\n  }\n\n  private getKeyRangeInternal(from: Key, to: Key) {\n    let keys: Key[] = [];\n    let key = from;\n    while (key) {\n      let item = this.collection.getItem(key);\n      if (item && item.type === 'item' || (item.type === 'cell' && this.allowsCellSelection)) {\n        keys.push(key);\n      }\n\n      if (key === to) {\n        return keys;\n      }\n\n      key = this.collection.getKeyAfter(key);\n    }\n\n    return [];\n  }\n\n  private getKey(key: Key) {\n    let item = this.collection.getItem(key);\n    if (!item) {\n      // ¯\\_(ツ)_/¯\n      return key;\n    }\n\n    // If cell selection is allowed, just return the key.\n    if (item.type === 'cell' && this.allowsCellSelection) {\n      return key;\n    }\n\n    // Find a parent item to select\n    while (item.type !== 'item' && item.parentKey != null) {\n      item = this.collection.getItem(item.parentKey);\n    }\n\n    if (!item || item.type !== 'item') {\n      return null;\n    }\n\n    return item.key;\n  }\n\n  /**\n   * Toggles whether the given key is selected.\n   */\n  toggleSelection(key: Key) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    if (this.selectionMode === 'single' && !this.isSelected(key)) {\n      this.replaceSelection(key);\n      return;\n    }\n\n    key = this.getKey(key);\n    if (key == null) {\n      return;\n    }\n\n    let keys = new Selection(this.state.selectedKeys === 'all' ? this.getSelectAllKeys() : this.state.selectedKeys);\n    if (keys.has(key)) {\n      keys.delete(key);\n      // TODO: move anchor to last selected key...\n      // Does `current` need to move here too?\n    } else if (this.canSelectItem(key)) {\n      keys.add(key);\n      keys.anchorKey = key;\n      keys.currentKey = key;\n    }\n\n    if (this.disallowEmptySelection && keys.size === 0) {\n      return;\n    }\n\n    this.state.setSelectedKeys(keys);\n  }\n\n  /**\n   * Replaces the selection with only the given key.\n   */\n  replaceSelection(key: Key) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    key = this.getKey(key);\n    if (key == null) {\n      return;\n    }\n\n    let selection = this.canSelectItem(key)\n      ? new Selection([key], key, key)\n      : new Selection();\n\n    this.state.setSelectedKeys(selection);\n  }\n\n  /**\n   * Replaces the selection with the given keys.\n   */\n  setSelectedKeys(keys: Iterable<Key>) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    let selection = new Selection();\n    for (let key of keys) {\n      key = this.getKey(key);\n      if (key != null) {\n        selection.add(key);\n        if (this.selectionMode === 'single') {\n          break;\n        }\n      }\n    }\n\n    this.state.setSelectedKeys(selection);\n  }\n\n  private getSelectAllKeys() {\n    let keys: Key[] = [];\n    let addKeys = (key: Key) => {\n      while (key) {\n        if (this.canSelectItem(key)) {\n          let item = this.collection.getItem(key);\n          if (item.type === 'item') {\n            keys.push(key);\n          }\n\n          // Add child keys. If cell selection is allowed, then include item children too.\n          if (item.hasChildNodes && (this.allowsCellSelection || item.type !== 'item')) {\n            addKeys(getFirstItem(getChildNodes(item, this.collection)).key);\n          }\n        }\n\n        key = this.collection.getKeyAfter(key);\n      }\n    };\n\n    addKeys(this.collection.getFirstKey());\n    return keys;\n  }\n\n  /**\n   * Selects all items in the collection.\n   */\n  selectAll() {\n    if (!this.isSelectAll && this.selectionMode === 'multiple') {\n      this.state.setSelectedKeys('all');\n    }\n  }\n\n  /**\n   * Removes all keys from the selection.\n   */\n  clearSelection() {\n    if (!this.disallowEmptySelection && (this.state.selectedKeys === 'all' || this.state.selectedKeys.size > 0)) {\n      this.state.setSelectedKeys(new Selection());\n    }\n  }\n\n  /**\n   * Toggles between select all and an empty selection.\n   */\n  toggleSelectAll() {\n    if (this.isSelectAll) {\n      this.clearSelection();\n    } else {\n      this.selectAll();\n    }\n  }\n\n  select(key: Key, e?: PressEvent | LongPressEvent | PointerEvent) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    if (this.selectionMode === 'single') {\n      if (this.isSelected(key) && !this.disallowEmptySelection) {\n        this.toggleSelection(key);\n      } else {\n        this.replaceSelection(key);\n      }\n    } else if (this.selectionBehavior === 'toggle' || (e && (e.pointerType === 'touch' || e.pointerType === 'virtual'))) {\n      // if touch or virtual (VO) then we just want to toggle, otherwise it's impossible to multi select because they don't have modifier keys\n      this.toggleSelection(key);\n    } else {\n      this.replaceSelection(key);\n    }\n  }\n\n  /**\n   * Returns whether the current selection is equal to the given selection.\n   */\n  isSelectionEqual(selection: Set<Key>) {\n    if (selection === this.state.selectedKeys) {\n      return true;\n    }\n\n    // Check if the set of keys match.\n    let selectedKeys = this.selectedKeys;\n    if (selection.size !== selectedKeys.size) {\n      return false;\n    }\n\n    for (let key of selection) {\n      if (!selectedKeys.has(key)) {\n        return false;\n      }\n    }\n\n    for (let key of selectedKeys) {\n      if (!selection.has(key)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  canSelectItem(key: Key) {\n    if (this.state.selectionMode === 'none' || this.state.disabledKeys.has(key)) {\n      return false;\n    }\n\n    let item = this.collection.getItem(key);\n    if (!item || item?.props?.isDisabled || (item.type === 'cell' && !this.allowsCellSelection)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  isDisabled(key: Key) {\n    return this.state.disabledBehavior === 'all' && (this.state.disabledKeys.has(key) || !!this.collection.getItem(key)?.props?.isDisabled);\n  }\n\n  isLink(key: Key) {\n    return !!this.collection.getItem(key)?.props?.href;\n  }\n\n  getItemProps(key: Key) {\n    return this.collection.getItem(key)?.props;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}