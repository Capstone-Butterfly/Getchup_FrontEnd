{"ast":null,"code":"import { getChildNodes as $7nPCv$getChildNodes, getLastItem as $7nPCv$getLastItem, getFirstItem as $7nPCv$getFirstItem } from \"@react-stately/collections\";\nimport { useMultipleSelectionState as $7nPCv$useMultipleSelectionState, SelectionManager as $7nPCv$SelectionManager } from \"@react-stately/selection\";\nimport { useMemo as $7nPCv$useMemo, useRef as $7nPCv$useRef, useEffect as $7nPCv$useEffect } from \"react\";\nfunction $62967d126f3aa823$export$4007ac09ff9c68ed(props) {\n  let {\n    collection: collection,\n    focusMode: focusMode\n  } = props;\n  let selectionState = (0, $7nPCv$useMultipleSelectionState)(props);\n  let disabledKeys = (0, $7nPCv$useMemo)(() => props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [props.disabledKeys]);\n  let setFocusedKey = selectionState.setFocusedKey;\n  selectionState.setFocusedKey = (key, child) => {\n    if (focusMode === 'cell' && key != null) {\n      let item = collection.getItem(key);\n      if ((item === null || item === void 0 ? void 0 : item.type) === 'item') {\n        var _getLastItem, _getFirstItem;\n        let children = (0, $7nPCv$getChildNodes)(item, collection);\n        if (child === 'last') key = (_getLastItem = (0, $7nPCv$getLastItem)(children)) === null || _getLastItem === void 0 ? void 0 : _getLastItem.key;else key = (_getFirstItem = (0, $7nPCv$getFirstItem)(children)) === null || _getFirstItem === void 0 ? void 0 : _getFirstItem.key;\n      }\n    }\n    setFocusedKey(key, child);\n  };\n  let selectionManager = (0, $7nPCv$useMemo)(() => new (0, $7nPCv$SelectionManager)(collection, selectionState), [collection, selectionState]);\n  const cachedCollection = (0, $7nPCv$useRef)(null);\n  (0, $7nPCv$useEffect)(() => {\n    if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) {\n      const node = cachedCollection.current.getItem(selectionState.focusedKey);\n      const parentNode = node.parentKey != null && (node.type === 'cell' || node.type === 'rowheader' || node.type === 'column') ? cachedCollection.current.getItem(node.parentKey) : node;\n      const cachedRows = cachedCollection.current.rows;\n      const rows = collection.rows;\n      const diff = cachedRows.length - rows.length;\n      let index = Math.min(diff > 1 ? Math.max(parentNode.index - diff + 1, 0) : parentNode.index, rows.length - 1);\n      let newRow;\n      while (index >= 0) {\n        if (!selectionManager.isDisabled(rows[index].key) && rows[index].type !== 'headerrow') {\n          newRow = rows[index];\n          break;\n        }\n        if (index < rows.length - 1) index++;else {\n          if (index > parentNode.index) index = parentNode.index;\n          index--;\n        }\n      }\n      if (newRow) {\n        const childNodes = newRow.hasChildNodes ? [...(0, $7nPCv$getChildNodes)(newRow, collection)] : [];\n        const keyToFocus = newRow.hasChildNodes && parentNode !== node && node.index < childNodes.length ? childNodes[node.index].key : newRow.key;\n        selectionState.setFocusedKey(keyToFocus);\n      } else selectionState.setFocusedKey(null);\n    }\n    cachedCollection.current = collection;\n  }, [collection, selectionManager, selectionState, selectionState.focusedKey]);\n  return {\n    collection: collection,\n    disabledKeys: disabledKeys,\n    isKeyboardNavigationDisabled: false,\n    selectionManager: selectionManager\n  };\n}\nexport { $62967d126f3aa823$export$4007ac09ff9c68ed as useGridState };","map":{"version":3,"names":["$62967d126f3aa823$export$4007ac09ff9c68ed","props","collection","focusMode","selectionState","$7nPCv$useMultipleSelectionState","disabledKeys","$7nPCv$useMemo","Set","setFocusedKey","key","child","item","getItem","type","_getLastItem","_getFirstItem","children","$7nPCv$getChildNodes","$7nPCv$getLastItem","$7nPCv$getFirstItem","selectionManager","$7nPCv$SelectionManager","cachedCollection","$7nPCv$useRef","$7nPCv$useEffect","focusedKey","node","current","parentNode","parentKey","cachedRows","rows","diff","length","index","Math","min","max","newRow","isDisabled","childNodes","hasChildNodes","keyToFocus","isKeyboardNavigationDisabled"],"sources":["/Users/farhang/Desktop/June 17 /Front/Getchup_FrontEnd/node_modules/@react-stately/grid/dist/packages/@react-stately/grid/src/useGridState.ts"],"sourcesContent":["import {getChildNodes, getFirstItem, getLastItem} from '@react-stately/collections';\nimport {GridCollection, GridNode} from '@react-types/grid';\nimport {Key} from '@react-types/shared';\nimport {MultipleSelectionStateProps, SelectionManager, useMultipleSelectionState} from '@react-stately/selection';\nimport {useEffect, useMemo, useRef} from 'react';\n\nexport interface GridState<T, C extends GridCollection<T>> {\n  collection: C,\n  /** A set of keys for rows that are disabled. */\n  disabledKeys: Set<Key>,\n  /** A selection manager to read and update row selection state. */\n  selectionManager: SelectionManager,\n  /** Whether keyboard navigation is disabled, such as when the arrow keys should be handled by a component within a cell. */\n  isKeyboardNavigationDisabled: boolean\n}\n\nexport interface GridStateOptions<T, C extends GridCollection<T>> extends MultipleSelectionStateProps {\n  collection: C,\n  disabledKeys?: Iterable<Key>,\n  focusMode?: 'row' | 'cell'\n}\n\n/**\n * Provides state management for a grid component. Handles row selection and focusing a grid cell's focusable child if applicable.\n */\nexport function useGridState<T extends object, C extends GridCollection<T>>(props: GridStateOptions<T, C>): GridState<T, C> {\n  let {collection, focusMode} = props;\n  let selectionState = useMultipleSelectionState(props);\n  let disabledKeys = useMemo(() =>\n      props.disabledKeys ? new Set(props.disabledKeys) : new Set<Key>()\n    , [props.disabledKeys]);\n\n  let setFocusedKey = selectionState.setFocusedKey;\n  selectionState.setFocusedKey = (key, child) => {\n    // If focusMode is cell and an item is focused, focus a child cell instead.\n    if (focusMode === 'cell' && key != null) {\n      let item = collection.getItem(key);\n      if (item?.type === 'item') {\n        let children = getChildNodes(item, collection);\n        if (child === 'last') {\n          key = getLastItem(children)?.key;\n        } else {\n          key = getFirstItem(children)?.key;\n        }\n      }\n    }\n\n    setFocusedKey(key, child);\n  };\n\n  let selectionManager = useMemo(() =>\n    new SelectionManager(collection, selectionState)\n    , [collection, selectionState]\n  );\n\n  // Reset focused key if that item is deleted from the collection.\n  const cachedCollection = useRef(null);\n  useEffect(() => {\n    if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) {\n      const node = cachedCollection.current.getItem(selectionState.focusedKey);\n      const parentNode =\n        node.parentKey != null && (node.type === 'cell' || node.type === 'rowheader' || node.type === 'column') ?\n        cachedCollection.current.getItem(node.parentKey) :\n        node;\n      const cachedRows = cachedCollection.current.rows;\n      const rows = collection.rows;\n      const diff = cachedRows.length - rows.length;\n      let index = Math.min(\n        (\n          diff > 1 ?\n          Math.max(parentNode.index - diff + 1, 0) :\n          parentNode.index\n        ),\n        rows.length - 1);\n      let newRow:GridNode<T>;\n      while (index >= 0) {\n        if (!selectionManager.isDisabled(rows[index].key) && rows[index].type !== 'headerrow') {\n          newRow = rows[index];\n          break;\n        }\n        // Find next, not disabled row.\n        if (index < rows.length - 1) {\n          index++;\n        // Otherwise, find previous, not disabled row.\n        } else {\n          if (index > parentNode.index) {\n            index = parentNode.index;\n          }\n          index--;\n        }\n      }\n      if (newRow) {\n        const childNodes = newRow.hasChildNodes ? [...getChildNodes(newRow, collection)] : [];\n        const keyToFocus =\n          newRow.hasChildNodes &&\n          parentNode !== node &&\n          node.index < childNodes.length ?\n          childNodes[node.index].key :\n          newRow.key;\n        selectionState.setFocusedKey(keyToFocus);\n      } else {\n        selectionState.setFocusedKey(null);\n      }\n    }\n    cachedCollection.current = collection;\n  }, [collection, selectionManager, selectionState, selectionState.focusedKey]);\n\n  return {\n    collection,\n    disabledKeys,\n    isKeyboardNavigationDisabled: false,\n    selectionManager\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}