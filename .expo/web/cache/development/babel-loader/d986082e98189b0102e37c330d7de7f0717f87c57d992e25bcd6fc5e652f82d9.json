{"ast":null,"code":"import { useLayoutEffect as $7mMvr$useLayoutEffect, isIOS as $7mMvr$isIOS, chain as $7mMvr$chain, getScrollParent as $7mMvr$getScrollParent } from \"@react-aria/utils\";\nconst $49c51c25361d4cd2$var$visualViewport = typeof document !== 'undefined' && window.visualViewport;\nconst $49c51c25361d4cd2$var$nonTextInputTypes = new Set(['checkbox', 'radio', 'range', 'color', 'file', 'image', 'button', 'submit', 'reset']);\nlet $49c51c25361d4cd2$var$preventScrollCount = 0;\nlet $49c51c25361d4cd2$var$restore;\nfunction $49c51c25361d4cd2$export$ee0f7cc6afcd1c18(options = {}) {\n  let {\n    isDisabled: isDisabled\n  } = options;\n  (0, $7mMvr$useLayoutEffect)(() => {\n    if (isDisabled) return;\n    $49c51c25361d4cd2$var$preventScrollCount++;\n    if ($49c51c25361d4cd2$var$preventScrollCount === 1) {\n      if ((0, $7mMvr$isIOS)()) $49c51c25361d4cd2$var$restore = $49c51c25361d4cd2$var$preventScrollMobileSafari();else $49c51c25361d4cd2$var$restore = $49c51c25361d4cd2$var$preventScrollStandard();\n    }\n    return () => {\n      $49c51c25361d4cd2$var$preventScrollCount--;\n      if ($49c51c25361d4cd2$var$preventScrollCount === 0) $49c51c25361d4cd2$var$restore();\n    };\n  }, [isDisabled]);\n}\nfunction $49c51c25361d4cd2$var$preventScrollStandard() {\n  return (0, $7mMvr$chain)($49c51c25361d4cd2$var$setStyle(document.documentElement, 'paddingRight', `${window.innerWidth - document.documentElement.clientWidth}px`), $49c51c25361d4cd2$var$setStyle(document.documentElement, 'overflow', 'hidden'));\n}\nfunction $49c51c25361d4cd2$var$preventScrollMobileSafari() {\n  let scrollable;\n  let restoreScrollableStyles;\n  let onTouchStart = e => {\n    scrollable = (0, $7mMvr$getScrollParent)(e.target, true);\n    if (scrollable === document.documentElement && scrollable === document.body) return;\n    if (scrollable instanceof HTMLElement && window.getComputedStyle(scrollable).overscrollBehavior === 'auto') restoreScrollableStyles = $49c51c25361d4cd2$var$setStyle(scrollable, 'overscrollBehavior', 'contain');\n  };\n  let onTouchMove = e => {\n    if (!scrollable || scrollable === document.documentElement || scrollable === document.body) {\n      e.preventDefault();\n      return;\n    }\n    if (scrollable.scrollHeight === scrollable.clientHeight && scrollable.scrollWidth === scrollable.clientWidth) e.preventDefault();\n  };\n  let onTouchEnd = e => {\n    let target = e.target;\n    if ($49c51c25361d4cd2$var$willOpenKeyboard(target) && target !== document.activeElement) {\n      e.preventDefault();\n      setupStyles();\n      target.style.transform = 'translateY(-2000px)';\n      target.focus();\n      requestAnimationFrame(() => {\n        target.style.transform = '';\n      });\n    }\n    if (restoreScrollableStyles) restoreScrollableStyles();\n  };\n  let onFocus = e => {\n    let target = e.target;\n    if ($49c51c25361d4cd2$var$willOpenKeyboard(target)) {\n      setupStyles();\n      target.style.transform = 'translateY(-2000px)';\n      requestAnimationFrame(() => {\n        target.style.transform = '';\n        if ($49c51c25361d4cd2$var$visualViewport) {\n          if ($49c51c25361d4cd2$var$visualViewport.height < window.innerHeight) requestAnimationFrame(() => {\n              $49c51c25361d4cd2$var$scrollIntoView(target);\n            });else $49c51c25361d4cd2$var$visualViewport.addEventListener('resize', () => $49c51c25361d4cd2$var$scrollIntoView(target), {\n              once: true\n            });\n        }\n      });\n    }\n  };\n  let restoreStyles = null;\n  let setupStyles = () => {\n    if (restoreStyles) return;\n    let onWindowScroll = () => {\n      window.scrollTo(0, 0);\n    };\n    let scrollX = window.pageXOffset;\n    let scrollY = window.pageYOffset;\n    restoreStyles = (0, $7mMvr$chain)($49c51c25361d4cd2$var$addEvent(window, 'scroll', onWindowScroll), $49c51c25361d4cd2$var$setStyle(document.documentElement, 'paddingRight', `${window.innerWidth - document.documentElement.clientWidth}px`), $49c51c25361d4cd2$var$setStyle(document.documentElement, 'overflow', 'hidden'), $49c51c25361d4cd2$var$setStyle(document.body, 'marginTop', `-${scrollY}px`), () => {\n      window.scrollTo(scrollX, scrollY);\n    });\n    window.scrollTo(0, 0);\n  };\n  let removeEvents = (0, $7mMvr$chain)($49c51c25361d4cd2$var$addEvent(document, 'touchstart', onTouchStart, {\n    passive: false,\n    capture: true\n  }), $49c51c25361d4cd2$var$addEvent(document, 'touchmove', onTouchMove, {\n    passive: false,\n    capture: true\n  }), $49c51c25361d4cd2$var$addEvent(document, 'touchend', onTouchEnd, {\n    passive: false,\n    capture: true\n  }), $49c51c25361d4cd2$var$addEvent(document, 'focus', onFocus, true));\n  return () => {\n    restoreScrollableStyles === null || restoreScrollableStyles === void 0 ? void 0 : restoreScrollableStyles();\n    restoreStyles === null || restoreStyles === void 0 ? void 0 : restoreStyles();\n    removeEvents();\n  };\n}\nfunction $49c51c25361d4cd2$var$setStyle(element, style, value) {\n  let cur = element.style[style];\n  element.style[style] = value;\n  return () => {\n    element.style[style] = cur;\n  };\n}\nfunction $49c51c25361d4cd2$var$addEvent(target, event, handler, options) {\n  target.addEventListener(event, handler, options);\n  return () => {\n    target.removeEventListener(event, handler, options);\n  };\n}\nfunction $49c51c25361d4cd2$var$scrollIntoView(target) {\n  let root = document.scrollingElement || document.documentElement;\n  while (target && target !== root) {\n    let scrollable = (0, $7mMvr$getScrollParent)(target);\n    if (scrollable !== document.documentElement && scrollable !== document.body && scrollable !== target) {\n      let scrollableTop = scrollable.getBoundingClientRect().top;\n      let targetTop = target.getBoundingClientRect().top;\n      if (targetTop > scrollableTop + target.clientHeight) scrollable.scrollTop += targetTop - scrollableTop;\n    }\n    target = scrollable.parentElement;\n  }\n}\nfunction $49c51c25361d4cd2$var$willOpenKeyboard(target) {\n  return target instanceof HTMLInputElement && !$49c51c25361d4cd2$var$nonTextInputTypes.has(target.type) || target instanceof HTMLTextAreaElement || target instanceof HTMLElement && target.isContentEditable;\n}\nexport { $49c51c25361d4cd2$export$ee0f7cc6afcd1c18 as usePreventScroll };","map":{"version":3,"names":["$49c51c25361d4cd2$var$visualViewport","document","window","visualViewport","$49c51c25361d4cd2$var$nonTextInputTypes","Set","$49c51c25361d4cd2$var$preventScrollCount","$49c51c25361d4cd2$var$restore","$49c51c25361d4cd2$export$ee0f7cc6afcd1c18","options","isDisabled","$7mMvr$useLayoutEffect","$7mMvr$isIOS","$49c51c25361d4cd2$var$preventScrollMobileSafari","$49c51c25361d4cd2$var$preventScrollStandard","$7mMvr$chain","$49c51c25361d4cd2$var$setStyle","documentElement","innerWidth","clientWidth","scrollable","restoreScrollableStyles","onTouchStart","e","$7mMvr$getScrollParent","target","body","HTMLElement","getComputedStyle","overscrollBehavior","onTouchMove","preventDefault","scrollHeight","clientHeight","scrollWidth","onTouchEnd","$49c51c25361d4cd2$var$willOpenKeyboard","activeElement","setupStyles","style","transform","focus","requestAnimationFrame","onFocus","height","innerHeight","$49c51c25361d4cd2$var$scrollIntoView","addEventListener","once","restoreStyles","onWindowScroll","scrollTo","scrollX","pageXOffset","scrollY","pageYOffset","$49c51c25361d4cd2$var$addEvent","removeEvents","passive","capture","element","value","cur","event","handler","removeEventListener","root","scrollingElement","scrollableTop","getBoundingClientRect","top","targetTop","scrollTop","parentElement","HTMLInputElement","has","type","HTMLTextAreaElement","isContentEditable"],"sources":["/Users/farhang/Desktop/June 17 /Front/Getchup_FrontEnd/node_modules/@react-aria/overlays/dist/packages/@react-aria/overlays/src/usePreventScroll.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {chain, getScrollParent, isIOS, useLayoutEffect} from '@react-aria/utils';\n\ninterface PreventScrollOptions {\n  /** Whether the scroll lock is disabled. */\n  isDisabled?: boolean\n}\n\n// @ts-ignore\nconst visualViewport = typeof document !== 'undefined' && window.visualViewport;\n\n// HTML input types that do not cause the software keyboard to appear.\nconst nonTextInputTypes = new Set([\n  'checkbox',\n  'radio',\n  'range',\n  'color',\n  'file',\n  'image',\n  'button',\n  'submit',\n  'reset'\n]);\n\n// The number of active usePreventScroll calls. Used to determine whether to revert back to the original page style/scroll position\nlet preventScrollCount = 0;\nlet restore;\n\n/**\n * Prevents scrolling on the document body on mount, and\n * restores it on unmount. Also ensures that content does not\n * shift due to the scrollbars disappearing.\n */\nexport function usePreventScroll(options: PreventScrollOptions = {}) {\n  let {isDisabled} = options;\n\n  useLayoutEffect(() => {\n    if (isDisabled) {\n      return;\n    }\n\n    preventScrollCount++;\n    if (preventScrollCount === 1) {\n      if (isIOS()) {\n        restore = preventScrollMobileSafari();\n      } else {\n        restore = preventScrollStandard();\n      }\n    }\n\n    return () => {\n      preventScrollCount--;\n      if (preventScrollCount === 0) {\n        restore();\n      }\n    };\n  }, [isDisabled]);\n}\n\n// For most browsers, all we need to do is set `overflow: hidden` on the root element, and\n// add some padding to prevent the page from shifting when the scrollbar is hidden.\nfunction preventScrollStandard() {\n  return chain(\n    setStyle(document.documentElement, 'paddingRight', `${window.innerWidth - document.documentElement.clientWidth}px`),\n    setStyle(document.documentElement, 'overflow', 'hidden')\n  );\n}\n\n// Mobile Safari is a whole different beast. Even with overflow: hidden,\n// it still scrolls the page in many situations:\n//\n// 1. When the bottom toolbar and address bar are collapsed, page scrolling is always allowed.\n// 2. When the keyboard is visible, the viewport does not resize. Instead, the keyboard covers part of\n//    it, so it becomes scrollable.\n// 3. When tapping on an input, the page always scrolls so that the input is centered in the visual viewport.\n//    This may cause even fixed position elements to scroll off the screen.\n// 4. When using the next/previous buttons in the keyboard to navigate between inputs, the whole page always\n//    scrolls, even if the input is inside a nested scrollable element that could be scrolled instead.\n//\n// In order to work around these cases, and prevent scrolling without jankiness, we do a few things:\n//\n// 1. Prevent default on `touchmove` events that are not in a scrollable element. This prevents touch scrolling\n//    on the window.\n// 2. Set `overscroll-behavior: contain` on nested scrollable regions so they do not scroll the page when at\n//    the top or bottom. Work around a bug where this does not work when the element does not actually overflow\n//    by preventing default in a `touchmove` event.\n// 3. Prevent default on `touchend` events on input elements and handle focusing the element ourselves.\n// 4. When focusing an input, apply a transform to trick Safari into thinking the input is at the top\n//    of the page, which prevents it from scrolling the page. After the input is focused, scroll the element\n//    into view ourselves, without scrolling the whole page.\n// 5. Offset the body by the scroll position using a negative margin and scroll to the top. This should appear the\n//    same visually, but makes the actual scroll position always zero. This is required to make all of the\n//    above work or Safari will still try to scroll the page when focusing an input.\n// 6. As a last resort, handle window scroll events, and scroll back to the top. This can happen when attempting\n//    to navigate to an input with the next/previous buttons that's outside a modal.\nfunction preventScrollMobileSafari() {\n  let scrollable: Element;\n  let restoreScrollableStyles;\n  let onTouchStart = (e: TouchEvent) => {\n    // Store the nearest scrollable parent element from the element that the user touched.\n    scrollable = getScrollParent(e.target as Element, true);\n    if (scrollable === document.documentElement && scrollable === document.body) {\n      return;\n    }\n\n    // Prevent scrolling up when at the top and scrolling down when at the bottom\n    // of a nested scrollable area, otherwise mobile Safari will start scrolling\n    // the window instead.\n    if (scrollable instanceof HTMLElement && window.getComputedStyle(scrollable).overscrollBehavior === 'auto') {\n      restoreScrollableStyles = setStyle(scrollable, 'overscrollBehavior', 'contain');\n    }\n  };\n\n  let onTouchMove = (e: TouchEvent) => {\n    // Prevent scrolling the window.\n    if (!scrollable || scrollable === document.documentElement || scrollable === document.body) {\n      e.preventDefault();\n      return;\n    }\n\n    // overscroll-behavior should prevent scroll chaining, but currently does not\n    // if the element doesn't actually overflow. https://bugs.webkit.org/show_bug.cgi?id=243452\n    // This checks that both the width and height do not overflow, otherwise we might\n    // block horizontal scrolling too. In that case, adding `touch-action: pan-x` to\n    // the element will prevent vertical page scrolling. We can't add that automatically\n    // because it must be set before the touchstart event.\n    if (scrollable.scrollHeight === scrollable.clientHeight && scrollable.scrollWidth === scrollable.clientWidth) {\n      e.preventDefault();\n    }\n  };\n\n  let onTouchEnd = (e: TouchEvent) => {\n    let target = e.target as HTMLElement;\n\n    // Apply this change if we're not already focused on the target element\n    if (willOpenKeyboard(target) && target !== document.activeElement) {\n      e.preventDefault();\n      setupStyles();\n\n      // Apply a transform to trick Safari into thinking the input is at the top of the page\n      // so it doesn't try to scroll it into view. When tapping on an input, this needs to\n      // be done before the \"focus\" event, so we have to focus the element ourselves.\n      target.style.transform = 'translateY(-2000px)';\n      target.focus();\n      requestAnimationFrame(() => {\n        target.style.transform = '';\n      });\n    }\n\n    if (restoreScrollableStyles) {\n      restoreScrollableStyles();\n    }\n  };\n\n  let onFocus = (e: FocusEvent) => {\n    let target = e.target as HTMLElement;\n    if (willOpenKeyboard(target)) {\n      setupStyles();\n\n      // Transform also needs to be applied in the focus event in cases where focus moves\n      // other than tapping on an input directly, e.g. the next/previous buttons in the\n      // software keyboard. In these cases, it seems applying the transform in the focus event\n      // is good enough, whereas when tapping an input, it must be done before the focus event. ðŸ¤·â€â™‚ï¸\n      target.style.transform = 'translateY(-2000px)';\n      requestAnimationFrame(() => {\n        target.style.transform = '';\n\n        // This will have prevented the browser from scrolling the focused element into view,\n        // so we need to do this ourselves in a way that doesn't cause the whole page to scroll.\n        if (visualViewport) {\n          if (visualViewport.height < window.innerHeight) {\n            // If the keyboard is already visible, do this after one additional frame\n            // to wait for the transform to be removed.\n            requestAnimationFrame(() => {\n              scrollIntoView(target);\n            });\n          } else {\n            // Otherwise, wait for the visual viewport to resize before scrolling so we can\n            // measure the correct position to scroll to.\n            visualViewport.addEventListener('resize', () => scrollIntoView(target), {once: true});\n          }\n        }\n      });\n    }\n  };\n\n  let restoreStyles = null;\n  let setupStyles = () => {\n    if (restoreStyles) {\n      return;\n    }\n\n    let onWindowScroll = () => {\n      // Last resort. If the window scrolled, scroll it back to the top.\n      // It should always be at the top because the body will have a negative margin (see below).\n      window.scrollTo(0, 0);\n    };\n\n    // Record the original scroll position so we can restore it.\n    // Then apply a negative margin to the body to offset it by the scroll position. This will\n    // enable us to scroll the window to the top, which is required for the rest of this to work.\n    let scrollX = window.pageXOffset;\n    let scrollY = window.pageYOffset;\n\n    restoreStyles = chain(\n      addEvent(window, 'scroll', onWindowScroll),\n      setStyle(document.documentElement, 'paddingRight', `${window.innerWidth - document.documentElement.clientWidth}px`),\n      setStyle(document.documentElement, 'overflow', 'hidden'),\n      setStyle(document.body, 'marginTop', `-${scrollY}px`),\n      () => {\n        window.scrollTo(scrollX, scrollY);\n      }\n    );\n\n    // Scroll to the top. The negative margin on the body will make this appear the same.\n    window.scrollTo(0, 0);\n  };\n\n  let removeEvents = chain(\n    addEvent(document, 'touchstart', onTouchStart, {passive: false, capture: true}),\n    addEvent(document, 'touchmove', onTouchMove, {passive: false, capture: true}),\n    addEvent(document, 'touchend', onTouchEnd, {passive: false, capture: true}),\n    addEvent(document, 'focus', onFocus, true)\n  );\n\n  return () => {\n    // Restore styles and scroll the page back to where it was.\n    restoreScrollableStyles?.();\n    restoreStyles?.();\n    removeEvents();\n  };\n}\n\n// Sets a CSS property on an element, and returns a function to revert it to the previous value.\nfunction setStyle(element: HTMLElement, style: string, value: string) {\n  let cur = element.style[style];\n  element.style[style] = value;\n\n  return () => {\n    element.style[style] = cur;\n  };\n}\n\n// Adds an event listener to an element, and returns a function to remove it.\nfunction addEvent<K extends keyof GlobalEventHandlersEventMap>(\n  target: EventTarget,\n  event: K,\n  handler: (this: Document, ev: GlobalEventHandlersEventMap[K]) => any,\n  options?: boolean | AddEventListenerOptions\n) {\n  target.addEventListener(event, handler, options);\n  return () => {\n    target.removeEventListener(event, handler, options);\n  };\n}\n\nfunction scrollIntoView(target: Element) {\n  let root = document.scrollingElement || document.documentElement;\n  while (target && target !== root) {\n    // Find the parent scrollable element and adjust the scroll position if the target is not already in view.\n    let scrollable = getScrollParent(target);\n    if (scrollable !== document.documentElement && scrollable !== document.body && scrollable !== target) {\n      let scrollableTop = scrollable.getBoundingClientRect().top;\n      let targetTop = target.getBoundingClientRect().top;\n      if (targetTop > scrollableTop + target.clientHeight) {\n        scrollable.scrollTop += targetTop - scrollableTop;\n      }\n    }\n\n    target = scrollable.parentElement;\n  }\n}\n\nfunction willOpenKeyboard(target: Element) {\n  return (\n    (target instanceof HTMLInputElement && !nonTextInputTypes.has(target.type)) ||\n    target instanceof HTMLTextAreaElement ||\n    (target instanceof HTMLElement && target.isContentEditable)\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}