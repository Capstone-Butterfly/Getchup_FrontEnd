{"ast":null,"code":"import { TableColumnLayout as $a9e7ae544a4e41dd$export$7ff77a162970b30e } from \"./TableColumnLayout.mjs\";\nimport { useState as $cPT3l$useState, useMemo as $cPT3l$useMemo, useCallback as $cPT3l$useCallback } from \"react\";\nfunction $292bc4e09cd0eb62$export$cb895dcf85db1319(props, state) {\n  let {\n    getDefaultWidth: getDefaultWidth,\n    getDefaultMinWidth: getDefaultMinWidth,\n    tableWidth = 0\n  } = props;\n  let [resizingColumn, setResizingColumn] = (0, $cPT3l$useState)(null);\n  let columnLayout = (0, $cPT3l$useMemo)(() => new (0, $a9e7ae544a4e41dd$export$7ff77a162970b30e)({\n    getDefaultWidth: getDefaultWidth,\n    getDefaultMinWidth: getDefaultMinWidth\n  }), [getDefaultWidth, getDefaultMinWidth]);\n  let [controlledColumns, uncontrolledColumns] = (0, $cPT3l$useMemo)(() => columnLayout.splitColumnsIntoControlledAndUncontrolled(state.collection.columns), [state.collection.columns, columnLayout]);\n  let [uncontrolledWidths, setUncontrolledWidths] = (0, $cPT3l$useState)(() => columnLayout.getInitialUncontrolledWidths(uncontrolledColumns));\n  let [lastColumns, setLastColumns] = (0, $cPT3l$useState)(state.collection.columns);\n  if (state.collection.columns !== lastColumns) {\n    if (state.collection.columns.length !== lastColumns.length || state.collection.columns.some((c, i) => c.key !== lastColumns[i].key)) {\n      let newUncontrolledWidths = columnLayout.getInitialUncontrolledWidths(uncontrolledColumns);\n      setUncontrolledWidths(newUncontrolledWidths);\n    }\n    setLastColumns(state.collection.columns);\n  }\n  let colWidths = (0, $cPT3l$useMemo)(() => columnLayout.recombineColumns(state.collection.columns, uncontrolledWidths, uncontrolledColumns, controlledColumns), [state.collection.columns, uncontrolledWidths, uncontrolledColumns, controlledColumns, columnLayout]);\n  let startResize = (0, $cPT3l$useCallback)(key => {\n    setResizingColumn(key);\n  }, [setResizingColumn]);\n  let updateResizedColumns = (0, $cPT3l$useCallback)((key, width) => {\n    let newControlled = new Map(Array.from(controlledColumns).map(([key, entry]) => [key, entry.props.width]));\n    let newSizes = columnLayout.resizeColumnWidth(tableWidth, state.collection, newControlled, uncontrolledWidths, key, width);\n    let map = new Map(Array.from(uncontrolledColumns).map(([key]) => [key, newSizes.get(key)]));\n    map.set(key, width);\n    setUncontrolledWidths(map);\n    return newSizes;\n  }, [controlledColumns, uncontrolledColumns, setUncontrolledWidths, tableWidth, columnLayout, state.collection, uncontrolledWidths]);\n  let endResize = (0, $cPT3l$useCallback)(() => {\n    setResizingColumn(null);\n  }, [setResizingColumn]);\n  (0, $cPT3l$useMemo)(() => columnLayout.buildColumnWidths(tableWidth, state.collection, colWidths), [tableWidth, state.collection, colWidths, columnLayout]);\n  return (0, $cPT3l$useMemo)(() => ({\n    resizingColumn: resizingColumn,\n    updateResizedColumns: updateResizedColumns,\n    startResize: startResize,\n    endResize: endResize,\n    getColumnWidth: key => columnLayout.getColumnWidth(key),\n    getColumnMinWidth: key => columnLayout.getColumnMinWidth(key),\n    getColumnMaxWidth: key => columnLayout.getColumnMaxWidth(key),\n    tableState: state\n  }), [columnLayout, resizingColumn, updateResizedColumns, startResize, endResize, state]);\n}\nexport { $292bc4e09cd0eb62$export$cb895dcf85db1319 as useTableColumnResizeState };","map":{"version":3,"names":["$292bc4e09cd0eb62$export$cb895dcf85db1319","props","state","getDefaultWidth","getDefaultMinWidth","tableWidth","resizingColumn","setResizingColumn","$cPT3l$useState","columnLayout","$cPT3l$useMemo","$a9e7ae544a4e41dd$export$7ff77a162970b30e","controlledColumns","uncontrolledColumns","splitColumnsIntoControlledAndUncontrolled","collection","columns","uncontrolledWidths","setUncontrolledWidths","getInitialUncontrolledWidths","lastColumns","setLastColumns","length","some","c","i","key","newUncontrolledWidths","colWidths","recombineColumns","startResize","$cPT3l$useCallback","updateResizedColumns","width","newControlled","Map","Array","from","map","entry","newSizes","resizeColumnWidth","get","set","endResize","buildColumnWidths","getColumnWidth","getColumnMinWidth","getColumnMaxWidth","tableState"],"sources":["/Users/farhang/Desktop/June 17 /Front/Getchup_FrontEnd/node_modules/@react-stately/table/dist/packages/@react-stately/table/src/useTableColumnResizeState.ts"],"sourcesContent":["/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {ColumnSize} from '@react-types/table';\nimport {GridNode} from '@react-types/grid';\nimport {Key} from '@react-types/shared';\nimport {TableColumnLayout} from './TableColumnLayout';\nimport {TableState} from './useTableState';\nimport {useCallback, useMemo, useState} from 'react';\n\nexport interface TableColumnResizeStateProps<T> {\n  /**\n   * Current width of the table or table viewport that the columns\n   * should be calculated against.\n   */\n  tableWidth: number,\n  /** A function that is called to find the default width for a given column. */\n  getDefaultWidth?: (node: GridNode<T>) => ColumnSize | null | undefined,\n  /** A function that is called to find the default minWidth for a given column. */\n  getDefaultMinWidth?: (node: GridNode<T>) => ColumnSize | null | undefined\n}\nexport interface TableColumnResizeState<T> {\n  /**\n   * Called to update the state that a resize event has occurred.\n   * Returns the new widths for all columns based on the resized column.\n   */\n  updateResizedColumns: (key: Key, width: number) => Map<Key, ColumnSize>,\n  /** Callback for when onColumnResize has started. */\n  startResize: (key: Key) => void,\n  /** Callback for when onColumnResize has ended. */\n  endResize: () => void,\n  /** Gets the current width for the specified column. */\n  getColumnWidth: (key: Key) => number,\n  /** Gets the current minWidth for the specified column. */\n  getColumnMinWidth: (key: Key) => number,\n  /** Gets the current maxWidth for the specified column. */\n  getColumnMaxWidth: (key: Key) => number,\n  /** Key of the currently resizing column. */\n  resizingColumn: Key | null,\n  /** A reference to the table state. */\n  tableState: TableState<T>\n}\n\n/**\n * Provides column width state management for a table component with column resizing support. Handles building\n * a map of column widths calculated from the table's width and any provided column width information from the collection.\n * In addition, it tracks the currently resizing column and provides callbacks for updating the widths upon resize operations.\n * @param props - Props for the table.\n * @param state - State for the table, as returned by `useTableState`.\n */\nexport function useTableColumnResizeState<T>(props: TableColumnResizeStateProps<T>, state: TableState<T>): TableColumnResizeState<T> {\n  let {\n    getDefaultWidth,\n    getDefaultMinWidth,\n    tableWidth = 0\n  } = props;\n\n  let [resizingColumn, setResizingColumn] = useState<Key | null>(null);\n  let columnLayout = useMemo(\n    () => new TableColumnLayout({\n      getDefaultWidth,\n      getDefaultMinWidth\n    }),\n    [getDefaultWidth, getDefaultMinWidth]\n  );\n\n  let [controlledColumns, uncontrolledColumns] = useMemo(() =>\n      columnLayout.splitColumnsIntoControlledAndUncontrolled(state.collection.columns)\n  , [state.collection.columns, columnLayout]);\n\n  // uncontrolled column widths\n  let [uncontrolledWidths, setUncontrolledWidths] = useState(() =>\n    columnLayout.getInitialUncontrolledWidths(uncontrolledColumns)\n  );\n\n  // Update uncontrolled widths if the columns changed.\n  let [lastColumns, setLastColumns] = useState(state.collection.columns);\n  if (state.collection.columns !== lastColumns) {\n    if (\n      state.collection.columns.length !== lastColumns.length ||\n      state.collection.columns.some((c, i) => c.key !== lastColumns[i].key)\n    ) {\n      let newUncontrolledWidths = columnLayout.getInitialUncontrolledWidths(uncontrolledColumns);\n      setUncontrolledWidths(newUncontrolledWidths);\n    }\n    setLastColumns(state.collection.columns);\n  }\n\n  // combine columns back into one map that maintains same order as the columns\n  let colWidths = useMemo(() =>\n      columnLayout.recombineColumns(state.collection.columns, uncontrolledWidths, uncontrolledColumns, controlledColumns)\n  , [state.collection.columns, uncontrolledWidths, uncontrolledColumns, controlledColumns, columnLayout]);\n\n  let startResize = useCallback((key: Key) => {\n    setResizingColumn(key);\n  }, [setResizingColumn]);\n\n  let updateResizedColumns = useCallback((key: Key, width: number): Map<Key, ColumnSize> => {\n    let newControlled = new Map(Array.from(controlledColumns).map(([key, entry]) => [key, entry.props.width]));\n    let newSizes = columnLayout.resizeColumnWidth(tableWidth, state.collection, newControlled, uncontrolledWidths, key, width);\n\n    let map = new Map(Array.from(uncontrolledColumns).map(([key]) => [key, newSizes.get(key)]));\n    map.set(key, width);\n    setUncontrolledWidths(map);\n    return newSizes;\n  }, [controlledColumns, uncontrolledColumns, setUncontrolledWidths, tableWidth, columnLayout, state.collection, uncontrolledWidths]);\n\n  let endResize = useCallback(() => {\n    setResizingColumn(null);\n  }, [setResizingColumn]);\n\n  useMemo(() =>\n    columnLayout.buildColumnWidths(tableWidth, state.collection, colWidths)\n  , [tableWidth, state.collection, colWidths, columnLayout]);\n\n  return useMemo(() => ({\n    resizingColumn,\n    updateResizedColumns,\n    startResize,\n    endResize,\n    getColumnWidth: (key: Key) =>\n      columnLayout.getColumnWidth(key),\n    getColumnMinWidth: (key: Key) =>\n      columnLayout.getColumnMinWidth(key),\n    getColumnMaxWidth: (key: Key) =>\n      columnLayout.getColumnMaxWidth(key),\n    tableState: state\n  }), [\n    columnLayout,\n    resizingColumn,\n    updateResizedColumns,\n    startResize,\n    endResize,\n    state\n  ]);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}