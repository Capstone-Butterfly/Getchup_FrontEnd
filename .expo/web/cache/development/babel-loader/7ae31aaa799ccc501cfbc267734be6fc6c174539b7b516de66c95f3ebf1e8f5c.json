{"ast":null,"code":"import { useState as $lyPoT$useState, useRef as $lyPoT$useRef, useCallback as $lyPoT$useCallback } from \"react\";\nfunction $e672e8bc247525d1$export$926850f6ecef79d0(props) {\n  let {\n    acceptedDragTypes = 'all',\n    isDisabled: isDisabled,\n    onInsert: onInsert,\n    onRootDrop: onRootDrop,\n    onItemDrop: onItemDrop,\n    onReorder: onReorder,\n    shouldAcceptItemDrop: shouldAcceptItemDrop,\n    collection: collection,\n    selectionManager: selectionManager,\n    onDropEnter: onDropEnter,\n    getDropOperation: getDropOperation,\n    onDrop: onDrop\n  } = props;\n  let [target, setTarget] = (0, $lyPoT$useState)(null);\n  let targetRef = (0, $lyPoT$useRef)(null);\n  let getOppositeTarget = target => {\n    if (target.dropPosition === 'before') {\n      let key = collection.getKeyBefore(target.key);\n      return key != null ? {\n        type: 'item',\n        key: key,\n        dropPosition: 'after'\n      } : null;\n    } else if (target.dropPosition === 'after') {\n      let key = collection.getKeyAfter(target.key);\n      return key != null ? {\n        type: 'item',\n        key: key,\n        dropPosition: 'before'\n      } : null;\n    }\n  };\n  let defaultGetDropOperation = (0, $lyPoT$useCallback)(e => {\n    if (isDisabled) return 'cancel';\n    let {\n      target: target,\n      types: types,\n      allowedOperations: allowedOperations,\n      isInternal: isInternal,\n      draggingKeys: draggingKeys\n    } = e;\n    if (acceptedDragTypes === 'all' || acceptedDragTypes.some(type => types.has(type))) {\n      let isValidInsert = onInsert && target.type === 'item' && !isInternal && (target.dropPosition === 'before' || target.dropPosition === 'after');\n      let isValidReorder = onReorder && target.type === 'item' && isInternal && (target.dropPosition === 'before' || target.dropPosition === 'after');\n      let isValidRootDrop = onRootDrop && target.type === 'root' && !isInternal;\n      let isValidOnItemDrop = onItemDrop && target.type === 'item' && target.dropPosition === 'on' && !(isInternal && draggingKeys.has(target.key)) && (!shouldAcceptItemDrop || shouldAcceptItemDrop(target, types));\n      if (onDrop || isValidInsert || isValidReorder || isValidRootDrop || isValidOnItemDrop) {\n        if (getDropOperation) return getDropOperation(target, types, allowedOperations);else return allowedOperations[0];\n      }\n    }\n    return 'cancel';\n  }, [isDisabled, acceptedDragTypes, getDropOperation, onInsert, onRootDrop, onItemDrop, shouldAcceptItemDrop, onReorder, onDrop]);\n  return {\n    collection: collection,\n    selectionManager: selectionManager,\n    isDisabled: isDisabled,\n    target: target,\n    setTarget(newTarget) {\n      if (this.isDropTarget(newTarget)) return;\n      let target = targetRef.current;\n      if (target && typeof props.onDropExit === 'function') props.onDropExit({\n        type: 'dropexit',\n        x: 0,\n        y: 0,\n        target: target\n      });\n      if (newTarget && typeof onDropEnter === 'function') onDropEnter({\n        type: 'dropenter',\n        x: 0,\n        y: 0,\n        target: newTarget\n      });\n      targetRef.current = newTarget;\n      setTarget(newTarget);\n    },\n    isDropTarget(dropTarget) {\n      let target = targetRef.current;\n      if ($e672e8bc247525d1$var$isEqualDropTarget(dropTarget, target)) return true;\n      if ((dropTarget === null || dropTarget === void 0 ? void 0 : dropTarget.type) === 'item' && (target === null || target === void 0 ? void 0 : target.type) === 'item' && dropTarget.key !== target.key && dropTarget.dropPosition !== target.dropPosition && dropTarget.dropPosition !== 'on' && target.dropPosition !== 'on') return $e672e8bc247525d1$var$isEqualDropTarget(getOppositeTarget(dropTarget), target) || $e672e8bc247525d1$var$isEqualDropTarget(dropTarget, getOppositeTarget(target));\n      return false;\n    },\n    getDropOperation(e) {\n      return defaultGetDropOperation(e);\n    }\n  };\n}\nfunction $e672e8bc247525d1$var$isEqualDropTarget(a, b) {\n  if (!a) return !b;\n  switch (a.type) {\n    case 'root':\n      return (b === null || b === void 0 ? void 0 : b.type) === 'root';\n    case 'item':\n      return (b === null || b === void 0 ? void 0 : b.type) === 'item' && (b === null || b === void 0 ? void 0 : b.key) === a.key && (b === null || b === void 0 ? void 0 : b.dropPosition) === a.dropPosition;\n  }\n}\nexport { $e672e8bc247525d1$export$926850f6ecef79d0 as useDroppableCollectionState };","map":{"version":3,"names":["$e672e8bc247525d1$export$926850f6ecef79d0","props","acceptedDragTypes","isDisabled","onInsert","onRootDrop","onItemDrop","onReorder","shouldAcceptItemDrop","collection","selectionManager","onDropEnter","getDropOperation","onDrop","target","setTarget","$lyPoT$useState","targetRef","$lyPoT$useRef","getOppositeTarget","dropPosition","key","getKeyBefore","type","getKeyAfter","defaultGetDropOperation","$lyPoT$useCallback","e","types","allowedOperations","isInternal","draggingKeys","some","has","isValidInsert","isValidReorder","isValidRootDrop","isValidOnItemDrop","newTarget","isDropTarget","current","onDropExit","x","y","dropTarget","$e672e8bc247525d1$var$isEqualDropTarget","a","b"],"sources":["/Users/farhang/Desktop/June 17 /Front/Getchup_FrontEnd/node_modules/@react-stately/dnd/dist/packages/@react-stately/dnd/src/useDroppableCollectionState.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, DragTypes, DropOperation, DroppableCollectionProps, DropTarget, ItemDropTarget, Key, Node} from '@react-types/shared';\nimport {MultipleSelectionManager} from '@react-stately/selection';\nimport {useCallback, useRef, useState} from 'react';\n\ninterface DropOperationEvent {\n  target: DropTarget,\n  types: DragTypes,\n  allowedOperations: DropOperation[],\n  isInternal: boolean,\n  draggingKeys: Set<Key>\n}\n\nexport interface DroppableCollectionStateOptions extends Omit<DroppableCollectionProps, 'onDropMove' | 'onDropActivate'> {\n  /** A collection of items. */\n  collection: Collection<Node<unknown>>,\n  /** An interface for reading and updating multiple selection state. */\n  selectionManager: MultipleSelectionManager,\n  /** Whether the drop events should be disabled. */\n  isDisabled?: boolean\n}\n\nexport interface DroppableCollectionState {\n  /** A collection of items. */\n  collection: Collection<Node<unknown>>,\n  /** An interface for reading and updating multiple selection state. */\n  selectionManager: MultipleSelectionManager,\n  /** The current drop target. */\n  target: DropTarget | null,\n  /** Whether drop events are disabled. */\n  isDisabled?: boolean,\n  /** Sets the current drop target. */\n  setTarget(target: DropTarget): void,\n  /** Returns whether the given target is equivalent to the current drop target. */\n  isDropTarget(target: DropTarget): boolean,\n  /** Returns the drop operation for the given parameters. */\n  getDropOperation(e: DropOperationEvent): DropOperation\n}\n\n/**\n * Manages state for a droppable collection.\n */\nexport function useDroppableCollectionState(props: DroppableCollectionStateOptions): DroppableCollectionState  {\n  let {\n    acceptedDragTypes = 'all',\n    isDisabled,\n    onInsert,\n    onRootDrop,\n    onItemDrop,\n    onReorder,\n    shouldAcceptItemDrop,\n    collection,\n    selectionManager,\n    onDropEnter,\n    getDropOperation,\n    onDrop\n  } = props;\n  let [target, setTarget] = useState<DropTarget>(null);\n  let targetRef = useRef<DropTarget>(null);\n\n  let getOppositeTarget = (target: ItemDropTarget): ItemDropTarget => {\n    if (target.dropPosition === 'before') {\n      let key = collection.getKeyBefore(target.key);\n      return key != null ? {type: 'item', key, dropPosition: 'after'} : null;\n    } else if (target.dropPosition === 'after') {\n      let key = collection.getKeyAfter(target.key);\n      return key != null ? {type: 'item', key, dropPosition: 'before'} : null;\n    }\n  };\n\n  let defaultGetDropOperation = useCallback((e: DropOperationEvent) => {\n    if (isDisabled) {\n      return 'cancel';\n    }\n\n    let {\n      target,\n      types,\n      allowedOperations,\n      isInternal,\n      draggingKeys\n    } = e;\n\n    if (acceptedDragTypes === 'all' || acceptedDragTypes.some(type => types.has(type))) {\n      let isValidInsert = onInsert && target.type === 'item' && !isInternal && (target.dropPosition === 'before' || target.dropPosition === 'after');\n      let isValidReorder = onReorder && target.type === 'item' && isInternal && (target.dropPosition === 'before' || target.dropPosition === 'after');\n      // Feedback was that internal root drop was weird so preventing that from happening\n      let isValidRootDrop = onRootDrop && target.type === 'root' && !isInternal;\n      // Automatically prevent items (i.e. folders) from being dropped on themselves.\n      let isValidOnItemDrop = onItemDrop && target.type === 'item' && target.dropPosition === 'on' && !(isInternal && draggingKeys.has(target.key)) && (!shouldAcceptItemDrop || shouldAcceptItemDrop(target, types));\n\n      if (onDrop || isValidInsert || isValidReorder || isValidRootDrop || isValidOnItemDrop) {\n        if (getDropOperation) {\n          return getDropOperation(target, types, allowedOperations);\n        } else {\n          return allowedOperations[0];\n        }\n      }\n    }\n\n    return 'cancel';\n  }, [isDisabled, acceptedDragTypes, getDropOperation, onInsert, onRootDrop, onItemDrop, shouldAcceptItemDrop, onReorder, onDrop]);\n\n  return {\n    collection,\n    selectionManager,\n    isDisabled,\n    target,\n    setTarget(newTarget) {\n      if (this.isDropTarget(newTarget)) {\n        return;\n      }\n\n      let target = targetRef.current;\n      if (target && typeof props.onDropExit === 'function') {\n        props.onDropExit({\n          type: 'dropexit',\n          x: 0, // todo\n          y: 0,\n          target\n        });\n      }\n\n      if (newTarget && typeof onDropEnter === 'function') {\n        onDropEnter({\n          type: 'dropenter',\n          x: 0, // todo\n          y: 0,\n          target: newTarget\n        });\n      }\n\n      targetRef.current = newTarget;\n      setTarget(newTarget);\n    },\n    isDropTarget(dropTarget) {\n      let target = targetRef.current;\n      if (isEqualDropTarget(dropTarget, target)) {\n        return true;\n      }\n\n      // Check if the targets point at the same point between two items, one referring before, and the other after.\n      if (\n        dropTarget?.type === 'item' &&\n        target?.type === 'item' &&\n        dropTarget.key !== target.key &&\n        dropTarget.dropPosition !== target.dropPosition &&\n        dropTarget.dropPosition !== 'on' &&\n        target.dropPosition !== 'on'\n      ) {\n        return isEqualDropTarget(getOppositeTarget(dropTarget), target) ||\n          isEqualDropTarget(dropTarget, getOppositeTarget(target));\n      }\n\n      return false;\n    },\n    getDropOperation(e) {\n      return defaultGetDropOperation(e);\n    }\n  };\n}\n\nfunction isEqualDropTarget(a: DropTarget, b: DropTarget) {\n  if (!a) {\n    return !b;\n  }\n\n  switch (a.type) {\n    case 'root':\n      return b?.type === 'root';\n    case 'item':\n      return b?.type === 'item' && b?.key === a.key && b?.dropPosition === a.dropPosition;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}