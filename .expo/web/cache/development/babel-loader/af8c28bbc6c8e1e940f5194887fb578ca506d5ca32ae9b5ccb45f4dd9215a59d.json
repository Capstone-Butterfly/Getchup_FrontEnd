{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nclass $16805b1b18093c5f$export$de3fdf6493c353d {\n  *[Symbol.iterator]() {\n    yield* [...this.rows];\n  }\n  get size() {\n    return [...this.rows].length;\n  }\n  getKeys() {\n    return this.keyMap.keys();\n  }\n  getKeyBefore(key) {\n    let node = this.keyMap.get(key);\n    return node ? node.prevKey : null;\n  }\n  getKeyAfter(key) {\n    let node = this.keyMap.get(key);\n    return node ? node.nextKey : null;\n  }\n  getFirstKey() {\n    var _;\n    return (_ = [...this.rows][0]) === null || _ === void 0 ? void 0 : _.key;\n  }\n  getLastKey() {\n    var _rows_;\n    let rows = [...this.rows];\n    return (_rows_ = rows[rows.length - 1]) === null || _rows_ === void 0 ? void 0 : _rows_.key;\n  }\n  getItem(key) {\n    return this.keyMap.get(key);\n  }\n  at(idx) {\n    const keys = [...this.getKeys()];\n    return this.getItem(keys[idx]);\n  }\n  getChildren(key) {\n    let node = this.keyMap.get(key);\n    return (node === null || node === void 0 ? void 0 : node.childNodes) || [];\n  }\n  constructor(opts) {\n    this.keyMap = new Map();\n    this.keyMap = new Map();\n    this.columnCount = opts === null || opts === void 0 ? void 0 : opts.columnCount;\n    this.rows = [];\n    let visit = node => {\n      let prevNode = this.keyMap.get(node.key);\n      if (opts.visitNode) node = opts.visitNode(node);\n      this.keyMap.set(node.key, node);\n      let childKeys = new Set();\n      let last;\n      for (let child of node.childNodes) {\n        if (child.type === 'cell' && child.parentKey == null) child.parentKey = node.key;\n        childKeys.add(child.key);\n        if (last) {\n          last.nextKey = child.key;\n          child.prevKey = last.key;\n        } else child.prevKey = null;\n        visit(child);\n        last = child;\n      }\n      if (last) last.nextKey = null;\n      if (prevNode) {\n        for (let child of prevNode.childNodes) if (!childKeys.has(child.key)) remove(child);\n      }\n    };\n    let remove = node => {\n      this.keyMap.delete(node.key);\n      for (let child of node.childNodes) if (this.keyMap.get(child.key) === child) remove(child);\n    };\n    let last;\n    opts.items.forEach((node, i) => {\n      let rowNode = _objectSpread({\n        level: 0,\n        key: 'row-' + i,\n        type: 'row',\n        value: undefined,\n        hasChildNodes: true,\n        childNodes: [...node.childNodes],\n        rendered: undefined,\n        textValue: undefined\n      }, node);\n      if (last) {\n        last.nextKey = rowNode.key;\n        rowNode.prevKey = last.key;\n      } else rowNode.prevKey = null;\n      this.rows.push(rowNode);\n      visit(rowNode);\n      last = rowNode;\n    });\n    if (last) last.nextKey = null;\n  }\n}\nexport { $16805b1b18093c5f$export$de3fdf6493c353d as GridCollection };","map":{"version":3,"names":["$16805b1b18093c5f$export$de3fdf6493c353d","Symbol","iterator","rows","size","length","getKeys","keyMap","keys","getKeyBefore","key","node","get","prevKey","getKeyAfter","nextKey","getFirstKey","_","getLastKey","_rows_","getItem","at","idx","getChildren","childNodes","constructor","opts","Map","columnCount","visit","prevNode","visitNode","set","childKeys","Set","last","child","type","parentKey","add","has","remove","delete","items","forEach","i","rowNode","_objectSpread","level","value","undefined","hasChildNodes","rendered","textValue","push"],"sources":["/Users/farhang/Desktop/June 17 /Front/Getchup_FrontEnd/node_modules/@react-stately/grid/dist/packages/@react-stately/grid/src/GridCollection.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {GridNode, GridRow, GridCollection as IGridCollection} from '@react-types/grid';\nimport {Key} from '@react-types/shared';\n\ninterface GridCollectionOptions<T> {\n  columnCount: number,\n  items: GridRow<T>[],\n  visitNode?: (cell: GridNode<T>) => GridNode<T>\n}\n\nexport class GridCollection<T> implements IGridCollection<T> {\n  keyMap: Map<Key, GridNode<T>> = new Map();\n  columnCount: number;\n  rows: GridNode<T>[];\n\n  constructor(opts?: GridCollectionOptions<T>) {\n    this.keyMap = new Map();\n    this.columnCount = opts?.columnCount;\n    this.rows = [];\n\n    let visit = (node: GridNode<T>) => {\n      // If the node is the same object as the previous node for the same key,\n      // we can skip this node and its children. We always visit columns though,\n      // because we depend on order to build the columns array.\n      let prevNode = this.keyMap.get(node.key);\n      if (opts.visitNode) {\n        node = opts.visitNode(node);\n      }\n\n      this.keyMap.set(node.key, node);\n\n      let childKeys = new Set();\n      let last: GridNode<T>;\n      for (let child of node.childNodes) {\n        if (child.type === 'cell' && child.parentKey == null) {\n          // if child is a cell parent key isn't already established by the collection, match child node to parent row\n          child.parentKey = node.key;\n        }\n        childKeys.add(child.key);\n\n        if (last) {\n          last.nextKey = child.key;\n          child.prevKey = last.key;\n        } else {\n          child.prevKey = null;\n        }\n\n        visit(child);\n        last = child;\n      }\n\n      if (last) {\n        last.nextKey = null;\n      }\n\n      // Remove deleted nodes and their children from the key map\n      if (prevNode) {\n        for (let child of prevNode.childNodes) {\n          if (!childKeys.has(child.key)) {\n            remove(child);\n          }\n        }\n      }\n    };\n\n    let remove = (node: GridNode<T>) => {\n      this.keyMap.delete(node.key);\n      for (let child of node.childNodes) {\n        if (this.keyMap.get(child.key) === child) {\n          remove(child);\n        }\n      }\n    };\n\n    let last: GridNode<T>;\n    opts.items.forEach((node, i) => {\n      let rowNode = {\n        level: 0,\n        key: 'row-' + i,\n        type: 'row',\n        value: undefined,\n        hasChildNodes: true,\n        childNodes: [...node.childNodes],\n        rendered: undefined,\n        textValue: undefined,\n        ...node\n      } as GridNode<T>;\n\n      if (last) {\n        last.nextKey = rowNode.key;\n        rowNode.prevKey = last.key;\n      } else {\n        rowNode.prevKey = null;\n      }\n\n      this.rows.push(rowNode);\n      visit(rowNode);\n\n      last = rowNode;\n    });\n\n    if (last) {\n      last.nextKey = null;\n    }\n  }\n\n  *[Symbol.iterator]() {\n    yield* [...this.rows];\n  }\n\n  get size() {\n    return [...this.rows].length;\n  }\n\n  getKeys() {\n    return this.keyMap.keys();\n  }\n\n  getKeyBefore(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.prevKey : null;\n  }\n\n  getKeyAfter(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.nextKey : null;\n  }\n\n  getFirstKey() {\n    return [...this.rows][0]?.key;\n  }\n\n  getLastKey() {\n    let rows = [...this.rows];\n    return rows[rows.length - 1]?.key;\n  }\n\n  getItem(key: Key) {\n    return this.keyMap.get(key);\n  }\n\n  at(idx: number) {\n    const keys = [...this.getKeys()];\n    return this.getItem(keys[idx]);\n  }\n\n  getChildren(key: Key): Iterable<GridNode<T>> {\n    let node = this.keyMap.get(key);\n    return node?.childNodes || [];\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}